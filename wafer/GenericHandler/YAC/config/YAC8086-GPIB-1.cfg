# -----------------------------------------------------------------------------
#      This is a handler specific configuration file for handler drivers
#         (c) Copyright Agilent Technologies GmbH, Boeblingen 2000
# -----------------------------------------------------------------------------
# The general syntax of this file is:
#
#       file           = definitionlist
#
#       definitionlist = definition [definitionlist]
#
#       definition     = [hint] key [flags] data
#
#       key            = string ':'
#
#       data           = array | simple_data
#
#       simple_data    = number | quoted_string
#
#       quoted_string  = '"' string '"' | ''' string '''
#
#       array          = '[' datalist ']'
#
#       datalist       =  data [datalist]
#
#       hint           = '{' string '}'
#
#       flags          = '<' characterlist '>'
#
#       characterlist  = character [characterlist]
#
#       string         = alphanumeric string
#
#       number         = any floating point number
#
#       character      = 'F'
#
# Everything following a '#' character up to the end of the line, is 
# treated as a comment. A '#' within a string is handled correctly
# as part of the string.
#
# A <hint> group (several continuous lines) immediately preceding a 
# <definition> is used as a hint for this definition and may occur 
# in a user interface to give some advise for possible changes.
#
#           For a detailed description please refer to the document
#                     "Prober/Handler Drivers"
# -----------------------------------------------------------------------------



# Parameters for Equipment Identification -------------------------------------


# The name of the specific handler model within the handler family, as
# accepted by the plug-in

{ The name of the handler family. Must be defined, no default }

handler_family: < F >                   "YAC"

# The name of the specific handler model within the handler family, as
# accepted by the plug-in

{ The name of the handler model. Must be defined, no default }

model: < F >                            "8086"


# Parameters for Log File Generation ------------------------------------------


# In addition to printing messages to the Report Window, the driver
# can also write these messages to a file.  If the following value is
# not an empty string, it is treated as a log file for driver
# messages. Environment variable substitution in the path definition
# works.

{ The location of the drivers message log file, default: "" }

driver_message_log:                     "/var/opt/hp93000/soc/PH_libs/messages"

# For debugging purposes, the driver may generate more or less verbose
# messages. The level of verbosity is defined by this parameter.

{ The debug level of the driver, -1 to 4, or 9, default 1 }

debug_level:                            0

# In addition to printing warnings and errors to the Report Window,
# the driver can also write these to a file. Also `trace' information
# will be written to this file. If the following value is not an empty
# string, it is treated as an additional log file for errors and
# warnings. Environment variable substitution in the path definition
# works.

{ The location of the drivers error log file, default: "" }

driver_error_log:                       "/var/opt/hp93000/soc/PH_libs/errors"

# The messages and warnings/errors log files generated by the driver
# may be kept or overwritten with each start-up of the driver (each
# testprogram run), or with each change of one of the parameters
# driver_message_log or driver_error_log. This parameter sets the
# number of old log files to be kept by renaming the files following
# the scheme:
#
# file -> file_old_1 -> file_old_2 -> file_old_3 -> ...
# -> file_old_<log_files_to_keep>

{ How many old log files with similar names to keep, default: 0 }

log_files_to_keep:                      0

# At start-up, the driver may log its configuration to the message log
# output. If set to "yes", the configuration will be logged at the
# ph_driver_start call from the application model.

{ Log configuration to the message log file, "yes" or "no", default: "no" }

log_configuration: < F >                "yes"

# If set to "yes", the driver will add internal function calls
# together with the passed parameters to the warnings/error
# output. This should be used for debugging only.

{ Trace driver internal function calls, "yes" or "no, default: "no" }

trace_driver_calls:                     "no"


# Parameters for Driver Mode --------------------------------------------------


# For demonstrations, debug scenarios, and problem analysis, the
# driver may work in "off-line" mode rather then in "on-line"
# mode. During off-line mode, no communication with the equipment
# takes place. Instead, the equipment's behavior is simulated to the
# driver (error-free operation is simulated).

{ Interface communication mode, "on-line" or "off-line", default: "on-line" }

communication_mode: < F >               "on-line"

# Sometimes it is necessary for the operator to remove the handler
# from the tester and to do the device handling by hand. This may even
# be necessary during driver run-time. This parameter allows you to
# set the driver to the hand test mode. When running in this mode, the
# operator is prompted every time, a device handling action needs to
# be performed. Also, no driver communication to the handler takes
# place.

{ Activate hand test mode, "on" or "off", default: "off" }

hand_test_mode:                         "off"

# Sometimes it is necessary to slow down all driver operations, for
# example when testing a new application model, or when analyzing a
# malfunction. This parameter sets the driver to the single step
# mode. In single step mode the operator is prompted for confirmation
# at each call from the application model to the handler driver.

{ Activate singel step mode, "on" or "off", default: "off" }

single_step_mode:                       "off"


# Parameters for Operator interventions ---------------------------------------


# At driver startup, the operator may be asked to confirm the current
# configuration. If the operator confirms the configuration, handling
# operation will start. Otherwise, the testprogram will be
# aborted. The driver will only ask for configuration confirmation, if
# also the parameter log_configuration is set to "yes". This prints
# the current configuration file to the report window, and this way
# allows the operator to check the configuration before confirming it.

{ Ask for confirmation of the configuration at driver startup, default: "no" }

ask_for_configuration_confirmation: < F > "no"

# If a timeout occurs while the driver waits for the next part to be
# tested (next device from the handler, or next die on the wafer), the
# driver can ask the operator to take action ("operator-help"), or can
# continue waiting for parts ("continue"). In the latter case, the
# driver will stop waiting only if a new part is delivered by the
# handler or prober (and the delivery is recognized), or if one of the
# SmarTest flags ABORT, PAUSE, RESET, QUIT is set.
#
# Note: a new action "skip" is added for the Multi-Equipment-Control(MEC) 
# driver. "skip" means whenever timeout occurs, the driver will stop waiting 
# for the parts and the driver function will return with success. If MEC 
# driver is not used, the "skip" action should not be used.


{ What should happen, if a timeout occurs while waiting for parts,
  default: "continue" }

waiting_for_parts_timeout_action:       "continue"

# The time in seconds which the driver will wait for a new part (for
# handlers: the next device; for probers: the next die) from the
# equipment. If this time is exceeded (timeout), a message will be
# generated by the driver, and the action defined by the parameter
# waiting_for_parts_timeout_action will be taken.

{ Timeout in [seconds] to insert devices, default: 30 }

waiting_for_parts_timeout:              30

# The time in seconds which the driver will wait for a new lot to be
# started by the equipment. If this time is exceeded (timeout), a
# message will be generated by the driver, and the action defined by
# the parameters waiting_for_lot_timeout_action will be taken.
#
# Note: a new action "skip" is added for the Multi-Equipment-Control(MEC)
# driver. "skip" means whenever timeout occurs, the driver will stop waiting
# for the new lot start and the driver function  will return with success. 
# If MEC driver is not used, the "skip" action should not be used.

{ What should happen, if a timeout occurs while waiting for a lot start,
  default: "continue" }

waiting_for_lot_timeout_action:         "continue"

# The time in seconds which the driver will wait for the equipment to
# report that a new lot is ready to be tested. Some probers/handler
# send out a special signal in this situation. Others do not. To
# synchronize the start of SmarTest and the start of the equipment it
# is necessary for the driver to know, whether the signal has already
# been sent (and will not occur again) before the testprogram in
# SmarTest was started, or whether the driver still has to wait for
# the lot start signal. In the case of a timeout, a message will be
# generated by the driver, and the action defined by the parameter
# waiting_for_lot_timeout_action will be taken (see above). If the
# action is "operator-help", the operator can tell the driver to
# proceed as if the signal had been received.  The exact
# implementation of this function is plug-in specific.

{ Timeout in [seconds] to start a new lot, default: 120 }

waiting_for_lot_timeout:                30

# If a timeout occurs while the driver waits for any signals from the
# equipment, other than waiting for parts, wafers, cassettes or lots,
# the driver can ask the operator to take action ("operator-help"), or
# can continue waiting for the current action to complete
# ("continue"). In the latter case, the driver will stop waiting only
# if the action is completed, or if one of the SmarTest flags ABORT,
# PAUSE, RESET, QUIT is set.
#
# Note: a new action "skip" is added for the Multi-Equipment-Control(MEC)
# driver. "skip" means whenever timeout occurs, the driver will stop waiting
# for the signals and the driver function will return with success. If MEC 
# driver is not used, the "skip" action should not be used.

{ What should happen, if a general timeout occurs, default: "continue" }

general_timeout_action:                 "continue"

# The time in seconds which the driver will wait to receive any signal
# from the equipment, other than those signals for which the waiting
# time is defined by the parameters waiting_for_*_timeout (see
# above). The parameter general_timeout, for example, applies to
# communication requests when setting up parameters of the equipment,
# requesting values, pausing/unpausing, and asking for IDs.  If this
# time is exceeded (timeout), a message will be generated by the
# driver, and the action defined by the parameter
# general_timeout_action will be taken (see above).

{ Timeout in [seconds] to wait for completion of a general
  communication, default: 30 }

general_timeout:                        30

# This parameter determines whether the handler will be paused by the
# driver, when the SmarTest pause flag is set. (Typically, this is
# done by clicking Pause in the Operation Control window of SmarTest.)
# Depending on the handler type, the driver will make the handler
# leave the pause mode again, when the SmarTest pause mode is left, or
# the handler must be returned to normal operation by the operator.

{ Do we stop the prober in case SmarTest is paused, default: "no" }

stop_handler_on_smartest_pause:         "no"


# User Defined Dialog Box -----------------------------------------------------

# At certain key moments during the operation of the driver a configurable
# dialog box can be set to appear. The idea being that the operator may be
# prompted to perform some action to ensure the smooth operation of the
# prober/handler and the driver. For each user defined dialog box the
# following parameters may be defined:
#
# dialog_specific_key: [ "title" "message" "diag-format" "diag-freq" ]
#
# where:
#
# dialog_specific_key   is the configuration key value as defined below.
#                       For example, to make a user defined dialog box
#                       appear before any commmunication is sent to the
#                       prober/handler the "dialog_communication_start"
#                       key must be defined. If no such configuration key 
#                       value is defined the corresponding dialog box will
#                       not appear.
#
# "title"               is a user defined title or "standard" to display
#                       the default title.
#                       This parameter must be defined if the
#                       dialog_specific_key has been defined.
#
# "message"             is a user defined message or "standard" to display the
#                       default message.  Note that for a user defined message
#                       the '|' character can be used to create a new line in
#                       the message. See the example given below.
#
# "diag-format"         this parameter defines the button format of the dialog
#                       box and may be one of:
#                       "Quit-Cont"  for the two [ QUIT ] [ CONTINUE ] buttons
#                       "Cont"       for just the [ CONTINUE ] button
#                       This is an optional parameter, default "Quit-Cont".
#
# "diag-freq"           gives the frequency with which the dialog box should be
#                       displayed and may be one of:
#                       "never" for no dialog box to appear
#                       "once"  to appear only once
#                       "repeat" to always appear at the key moment defined by
#                       the dialog_specific_key
#                       This is an optional parameter, default "once".
#
# for example the following user defined dialog definition:
#
# dialog_communication_start: [ "Attention !" "Press Green button on XYZ prober.|Then press CONTINUE." "Cont" ]
#
# will mean the following dialog box
#
#           ============== Attention ! ==============
#           |                                       |
#           | Press Green button on XYZ prober.     |
#           | Then press CONTINUE.                  |
#           |                                       |
#           |             [ Continue ]              |
#           |                                       |
#           =========================================
#
#
# appears before any communication is sent to the prober/handler by the driver.
#



# User defined dialog box to appear before communication to the handler/
# prober starts. For details on how to set the parameters see the
# "User Defined Dialog" entry above. Note for the diag-freq setting
# "repeat" is not an allowable value.

{ User defined dialog box to be appear before any communication is sent to the
  prober/handler }

dialog_communication_start: < F >       [ "standard" "standard" "quit-cont" "never" ] 

# User defined dialog box to appear before any configuration values are
# sent to the handler/prober. For details on how to set the parameters see the
# "User Defined Dialog" entry above. Note for the diag-freq setting
# "repeat" is not an allowable value.

{ User defined dialog box to be appear before any configuration values are
  sent to the prober/handler }


dialog_configuration_start: < F >       [ "standard" "standard" "quit-cont" "never" ]


# Parameters for Interface Identification -------------------------------------


# Handlers or wafer probers may be connected through a GPIO, GPIB, 
# LAN(TCP/IP) or RS232 interface to the tester. (Some equipment even supports more
# than one interface type).  This parameter specifies the interface
# type used.  GPIO interfaces are of two types: "gpio" and "ngpio".
# "ngpio" refers to the new configuration where a GPIO E2790C card is
# used without the GPIO Interface Box E2828A-560. "gpio" refers to the
# old configuration where either a GPIO E2790C or a GPIO E2790B card
# is used with the GPIO Interface Box E2828A-560. "gpib" refers to a
# GPIB interface. "lan" refers to a LAN(TCP/IP) interface. "rs232"
# refers to a RS232 interface.

{ The handler interface type. Must be defined, no default }

interface_type: < F >                   "gpib"

# The name of the interface device. 
# For GPIB/GPIO interface, this symbolic name is known to the standard instrument 
# control library (SICL), which is declared to the SICL through the iosetup(1) 
# program and are stored in the file /etc/opt/sicl/hwconfig.cf.
# For LAN interface, the format of the symbolic interface looks like:
# "[TCP/UDP]/server_address/server_port"
# For example:
# 1. TCP/192.168.1.1/12345
# 2. UDP/192.168.1.1/12345
# 3. TCP/server_hostname/12345
# 4. UDP/server_hostname/12345
# For RS232 interface, the format of the symbolic interface look like:
# "rs232/dev/device_name"
# For example:
# "rs232/dev/ttyS0"

{ The name of the interface device. Must be defined, no default }

symbolic_interface_name: < F >          "hpib"

# The GPIB port number of the prober or handler. This parameter is not required
# for LAN interface.

{ The GPIB port number of the prober or handler, no default }

gpib_port: < F >                        1


# Parameters for Site Management ----------------------------------------------


# Specifies the number of sites of the handler, and the ID of each
# site. Each string element of the array is a site ID. The number of
# elements is the number of sites.
#
# The order and naming of the site IDs should match the handler
# documentation to avoid confusion. The left most entry refers to the
# first handler site, the right most entry refers to the last handler
# site.
#
# When a GPIO interface is used, the site IDs are not transferred to
# the handler. Still, the handler_site_ids array must be set up to
# tell the driver the number of handler sites. Also, the site IDs will
# be used by the driver during message and error logging.

{ The names of the handler sites, Must be defined, no default }

handler_site_ids:                       [ "1" ]

# This mask tells the driver which of the handler sites are active
# (=1) and which are (currently) deactivated (=0). The mask
# corresponds to handler_site_ids. Telling the driver about
# deactivated sites avoids unnecessary latency delays.

{ Mask of active handler sites, entries may be 0 or 1, default [ 1 1 1 ... ] }

handler_site_mask:                      [ 1 ]

# Site mapping (corresponds to handler site IDs):
# Each entry defines the SmarTest site, the corresponding handler site is
# feeding to. SmarTest site numbers always start with 1 and are
# incremental. I.e. if 4 sites are defined, the SmarTest site numbers
# 1 to 4 must occur in the site mapping, while the order of these
# numbers may vary.
#
# Example:
# Assuming the 'handler_site_ids' are set to                 [ "A" "B" "C" ]
# and the      'smartest_site_to_handler_site_map' is set to [  2   1   3  ]
#
# This situation would result in:
#
# handler site "A" is mapped to SmarTest site 2
# handler site "B" is mapped to SmarTest site 1
# handler site "c" is mapped to SmarTest site 3

{ Mapping of SmarTest sites to handler sites, entries are >= 1,
  default [ 1 2 3 ... ] }

smartest_site_to_handler_site_map:      [ 1 ]


# Bin management --------------------------------------------------------------


# This parameter selects one of the different ways the driver can map
# SmarTest bins to handler bins:
#
# - "default"
# - "mapped-hardbins"
# - "mapped-softbins"
#
# Whenever a device is binned to a specific SmarTest bin, the handler
# will receive the mapped handler bin code for this device. Depending
# on the mapping selected, more or less additional parameters must be
# set, as described below.
#
# "default" is the easiest way to specify the device
# binning. SmarTest's hardbin numbers are used for a mapping of
# SmarTest bins to handler bins in a straight one to one fashion: The
# SmarTest bin with hardbin number 0 is mapped to the first handler
# bin, the SmarTest bin with harbin number 1 is mapped to the second
# handler bin, and so on. There are no further parameters to be set.
#
# "mapped-hardbins" provides a method to assign (groups of) SmarTest
# bins to (groups of) handler bins. The hardbin numbers of the
# SmarTest bins are used for bin identification. To use this feature,
# the parameters handler_bin_ids and hardbin_to_handler_bin_map must
# be defined, as explained below.
#
# "mapped-softbins" provides a method to assign (groups of) SmarTest
# bins to (groups of) handler bins. The softbin codes of the SmarTest
# bins are used for bin identification. To use this feature, the
# parameters handler_bin_ids and softbin_to_handler_bin_map must be
# defined, as explained below.

{ Method of SmarTest to handler bin mapping. Must be defined, 
  "default", "mapped-hardbins", or "mapped-softbins" }

bin_mapping:                            "mapped-hardbins"

# Holds the IDs of the bins of a handler. The IDs used in the array
# must match the bin names as known to the handler's communication
# protocol. The IDs in the array are used by so-called `message based'
# handlers, which identify bins over the GPIB (IEEE-488) or RS232
# interface. When a handler is connected via a GPIO interface, the bin
# IDs are used for message and error logging of the driver, and to
# allow for the `mapped-hardbins' or `mapped-softbins' binning
# modes. For GPIO handlers, the bin naming is free, but it should
# match the handler documentation to avoid confusion.
#
# The definition of handler_bin_ids is optional, if the "default" bin
# mapping is used. It is mandatory, if either the "mapped-hardbins" or
# the "mapped-softbins" method is used.

{ The names of the handler bins, no default }

handler_bin_ids:                        [ "1" "2" "3" "4" "5" "6" "7" "8" "9" "A"  "B"  "C"  "D"  "E"  "F" ]

# Defines the handler bins to be used for unknown test results. A test
# result is unknown, if the device test was skipped or if the device
# was binned to SmarTest's 'otherwise' bin.
#
# If the parameter handler_bin_ids IS NOT defined (this is allowed
# when `default' bin mapping is used), the entries of the
# handler_retest_bins definition are directly interpreted as the
# plug-in internal bin numbers (which start with 0).
#
# If the parameter handler_bin_ids IS defined, the entries of the
# handler_retest_bins definition are interpreted as indices to the
# handler_bin_ids array. Note that the first entry in that array has
# the index number 0)
#
# Some handlers bin to a retest bin when they receive an end-of-test
# signal or a binning signal without receiving binning data (which
# specifies the bin). In this case handler_retest_bins must be
# assigned an empty list (handler_retest_bins: [ ]). For GPIO
# handlers, this only makes sense when bin_coding is "explicit".

{ List of handler retest bin indices, 0 to ..., default: no retest bins }

handler_retest_bins:                    [ ]

# Hardbin mapping (corresponds to handler bin IDs):
#
# The format of this definition is a list of lists of SmarTest hardbin
# numbers. Each of the inner SmarTest hardbin lists refers to one
# handler bin, which was defined in 'handler_bin_ids'. Equal SmarTest
# bins may be given in several lists. The handler driver than takes
# care about an equal handler bin usage distribution.
#
# To avoid confusions, this definition should only be given, if
# 'bin_mapping' was set to "mapped-hardbins"
#
# Detailed example:
#
# handler_retest_bins:        [ 4 5 ]
# handler_bin_ids:            [ "A" "B"   "C"     "D"   "E"  "F"  ]
# hardbin_to_handler_bin_map: [ [1] [2] [98 99] [98 99] [-1] [-1] ]
#
# Handler bin "A" will receive devices binned to hardbin 1
# Handler bin "B" will receive devices binned to hardbin 2
#
# Handler bins "C" and "D" will both receive devices binned to
# hardbin 98 or 99
#
# Handler bins "E" and "F" will both receive devices binned to hardbin -1
# (usually this is the SmarTest 'otherwise' bin) and also devices that
# were not tested or have no bins assigned for some other reasons
# (defined through the 'handler_retest_bins' definition).

{ SmartTest hard-bin to handler bin map,
  list of lists of SmarTest hard-bin numbers, no default }

hardbin_to_handler_bin_map:             [ [1] [2] [3] [4] [5] [6] [7] [8] [9] [10] [11] [12] [13] [14] [15] ]

# Some handlers allow to verify the transfered binning data before the
# tested parts are actually released from the test socket and sorted
# into the correct output bin. Doing this, communication problems
# between handler and driver can be detected (e.g. noise on the GPIB
# bus). If this parameter is set to "yes" and if the handler supports
# bin data verification, all bin data is verified after sending to the
# handler. Be aware that this verification takes some more
# communication steps compared to the regular binning and may increase
# the device handling time. The default is "no". If the parameter is
# not defined the mode as set up directly at the handler will be used.

{ verification of bin data transfer to handler/prober }

verify_bin_data:                        "yes"

# If the parameter "verify_bin_data" is set to "yes", it is possible
# to define the maximum number of retries, in case the verified
# binning data is corrupt. E.g. if this value is set to 1, binning
# data will be send again one time and verified again before the
# driver issues a fatal error message and stops. If not given, the
# default value is defined to be 1.

{ maximum number of retries during automatic bin data verification }

verify_retry_count:                     1


# Parameters for Reprobe Activation -------------------------------------------

# NOTE: Reprobe is usually not supported by GPIO handlers.



# Parameters for Temperature Setup --------------------------------------------



# Parameters for GPIO Waveform Setup ------------------------------------------



# Plugin specific parameters --------------------------------------------------


# Parameters for Driver Internals ---------------------------------------------


# These parameters control how the driver behaves while waiting for
# new parts to be tested, and when performing a timed sequence of
# actions.

# While waiting for parts, the driver repeatedly checks for changed
# SmarTest system flags to allow a reasonable reaction time on user
# interactions (for example, PAUSE or ABORT pressed while the driver
# is waiting for parts). This parameter sets the time interval for
# these periodic checks in milliseconds. From the user side, a short
# reaction time of the driver is wanted (ideal: no reaction
# time). From the driver side, a requested short reaction time causes
# additional overhead, as more time is spent for checking the flags,
# and may increase the reaction time on part insertion. Reasonable
# values for this parameter lie between 2000 and 7000 milliseconds.

{ Time interval to check for flags in milliseconds while waiting for parts,
  0 to ..., default: 5000 }

flag_check_interval:                    4000

# Determines whether the driver will use a "polling" or an "interrupt"
# based algorithm while waiting for parts.
# Either the driver repeatedly checks whether the handler has sent
# the test start signal (polling), or the driver expects an SRQ 
# from the handler to indicate parts are ready to test (interrupt).

{ How to wait for test-start signals on the GPIO port, "polling" or
  "interrupt", default: "polling" }

waiting_for_parts_method:               "interrupt"


# End of File -----------------------------------------------------------------
