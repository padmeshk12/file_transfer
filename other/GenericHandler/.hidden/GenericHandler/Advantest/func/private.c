/******************************************************************************
 *
 *       (c) Copyright Advantest Ltd., 2012
 *
 *-----------------------------------------------------------------------------
 *
 * MODULE   : private.c
 * CREATED  : 14 Nov 2012
 *
 * CONTENTS : Private handler specific implementation
 *
 * AUTHORS  : Xiaofei Han, initial revision
 *
 *-----------------------------------------------------------------------------
 *
 * HISTORY  : 14 Nov 2012, Xiaofei Han, created
 *
 * Instructions:
 *
 * 1) Copy this template to as many .c files as you require
 *
 * 2) Use the command 'make depend' to make visible the new
 *    source files to the makefile utility
 *
 *****************************************************************************/

/*--- system includes -------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>
#include <time.h>
#include <sys/time.h>
#include <errno.h>
#include <ctype.h>
#include <sys/types.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

/*--- module includes -------------------------------------------------------*/

#include "ph_tools.h"

#include "ph_log.h"
#include "ph_mhcom.h"
#include "ph_conf.h"
#include "ph_estate.h"
#include "ph_hfunc.h"

#include "ph_keys.h"
#include "gpib_conf.h"
#include "ph_GuiServer.h"
#include "ph_hfunc_private.h"
#ifdef USE_DMALLOC
    #include "dmalloc.h"
#endif

/*--- defines ---------------------------------------------------------------*/

/* this macro allows to test a not fully implemented plugin */
/* #define ALLOW_INCOMPLETE */
#undef ALLOW_INCOMPLETE

#ifdef ALLOW_INCOMPLETE
    #define ReturnNotYetImplemented(x) \
    phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR, \
        "%s not yet implemented (ignored)", x); \
    return PHFUNC_ERR_OK
#else
    #define ReturnNotYetImplemented(x) \
    phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR, \
        "%s not yet implemented", x); \
    return PHFUNC_ERR_NA
#endif

/* 
 *   Place filler for BINON/BINOFF command where there is no operational site 
 */

#define RETEST_BIN_IN_HANDLER "R"
#define RETEST_BIN_IN_MSG  "A"
#define NO_BINNING_RESULT  "A"

#define DUMMY_THERMAL_ALARM_FILE "/tmp/DummyThermalAlarm.tmp"
/*--- typedefs --------------------------------------------------------------*/

/*--- variable --------------------------------------------------------------*/
int thermalAlarmFlag = 0;                   /*thermal alarm flag*/
int deviceIDReloadFlag = 0;                 /*reload Device ID flag for GS1 enhancement*/
int finalLotEndFlag = 0;                    /*final lot end flag*/
void (*preSignalHandler)(int) = NULL;       /*previous behavior of the signal SIGUSR1*/
phFuncId_t handlerIDForThermalAlarmSimulation = NULL;   /*the driver plugin ID only used for dummy thermal alarm*/

/*--- declarations ----------------------------------------------------------*/
static void asyncSRQCallback(unsigned char statusByte, void *helperData);

/*--- functions -------------------------------------------------------------*/
/*****************************************************************************
 * Description:
 *      check the file which is generated by the Thermal Alarm simulation utility program
 *      if the file exist, it means the signal is triggered by the Thermal Alarm simulation utility program
 *      and we will directly call thermal alarm function
 *      otherwise, we will not trigger thermal alarm function
 ****************************************************************************/
static int checkUtilityFile()
{
    if(-1 != access(DUMMY_THERMAL_ALARM_FILE, F_OK))
    {
        phLogFuncMessage(handlerIDForThermalAlarmSimulation->myLogger, LOG_DEBUG,
                "Thermal alarm simulation program has triggered the SIGUSR1 for thermal alarm simulation");
        return 1;
    }
    phLogFuncMessage(handlerIDForThermalAlarmSimulation->myLogger, LOG_DEBUG,
            "other program has triggered the SIGUSR1");
    return 0;
}

/*****************************************************************************
 * Description:
 *      this function is the handler of SIGUSR1 which is registed in privateInit()
 *      it will perform thermal alarm simulation
 *      if the previous handler of SIGUSR1 exist
 *      we will call it after checking utility file and thermal alarm simulation
 ****************************************************************************/
static void dummyThermalAlarm(int signal)
{
    if(1 == checkUtilityFile())
    {
        /*the signal is triggered by thermal alarm simulation utility program*/
        asyncSRQCallback(handlerIDForThermalAlarmSimulation->p.thermalAlarmSRQList[0], handlerIDForThermalAlarmSimulation);
        if( 0!=remove(DUMMY_THERMAL_ALARM_FILE))
        {
            phLogFuncMessage(handlerIDForThermalAlarmSimulation->myLogger, LOG_DEBUG,
                    "the file \"/tmp/DummyThermalAlarm.tmp\" cannot be deleted, please delete it manually");
        }
    }
    if(SIG_ERR != preSignalHandler && SIG_IGN != preSignalHandler && NULL != preSignalHandler)
    {
        /*previous handler of SIGUSR1 exist*/
        phLogFuncMessage(handlerIDForThermalAlarmSimulation->myLogger, LOG_DEBUG, "SIGUSR1 has been registed before...now we will call the handler.");
        (*preSignalHandler)(signal);
    }
}

static void setStrUpper(char *s1)
{
    int i=0;

    while ( s1[i] )
    {
        s1[i]=toupper( s1[i] );
        ++i;
    }

    return;
}

static int localDelay_us(long microseconds) 
{
    long seconds;
    struct timeval delay;

    /* us must be converted to seconds and microseconds ** for use by select(2) */
    if (microseconds >= 1000000L)
    {
        seconds = microseconds / 1000000L;
        microseconds = microseconds % 1000000L;
    }
    else
    {
        seconds = 0;
    }

    delay.tv_sec = seconds; 
    delay.tv_usec = microseconds; 

    /* return 0, if select was interrupted, 1 otherwise */
    if (select(0, NULL, NULL, NULL, &delay) == -1 &&
        errno == EINTR)
        return 0;
    else
        return 1;
}

static void asyncSRQCallback(unsigned char statusByte, void *helperData)
{
#if 0
    phFuncId_t handlerID = (phFuncId_t)helperData;

    /*timestamp of thermal alarm*/
    struct timeval timeStamp;
    gettimeofday(&timeStamp, NULL);
    phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "asyncSRQCallback() called at %d(us), %d(s), Thermal Alarm SRQ Received", (int)timeStamp.tv_usec, (int)timeStamp.tv_sec);

    thermalAlarmFlag = 1;                                                       /*set thermal alarm flag*/
    
    /*phTcomLogDTR(handlerID->myTcom, "THERMAL ALARM");*/
    /*phTcomSetSystemFlag(handlerID->myTcom, PHTCOM_SF_CI_TM_CRASH_AS_FATAL, 1);  [>do not restart test method process<]*/
    /*phTcomSetSystemFlag(handlerID->myTcom, PHTCOM_SF_CI_EXIT_TESTFLOW, 1);      [>exit test flow<]*/

    /* thermal alarms */
#if 0
    gettimeofday(&timeStamp, NULL);
    phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_MESSAGE_1, "Search tmm BEG %d(us), %d(s)", (int)timeStamp.tv_usec, (int)timeStamp.tv_sec);

    /*stop tmm by popen*/
    FILE *pShellKillTmm = popen("/opt/hp93000/soc/testmethod/bin/tmm_console -e stopAll", "r");

    /*stop tmm by execv*/
    char *arg[] = {"tmm_console", "-e stopAll",NULL};
    int ipid = 0;
    if((ipid = fork())==0)
    {
        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_MESSAGE_1, "execv");
        if( execv("/opt/hp93000/soc/testmethod/bin/tmm_console", arg)<0 ) {
            phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_MESSAGE_1, "execv failed");
        }
    }
    else
    {
        waitpid(ipid, NULL, 0);
    }
#endif

    /*kill -9 to tmm, so test method can be stopped*/
    /*get test method process id by popen*/
    char szPopenCMD[MAX_SESSION_ID_LEN] = {0};
    sprintf(szPopenCMD, "ps -ef |grep [T]estMethodManager-process|grep %s|awk '{print $2}'", handlerID->p.szSession);

    FILE *pShellKillTmm = popen(szPopenCMD, "r");
    char szResulttmm[1024] = {0};
    if( NULL == pShellKillTmm)
    {
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "popen failed!!!");
    }
    else
    {
        fgets(szResulttmm, sizeof(szResulttmm), pShellKillTmm);
        int iPID = atoi(szResulttmm);
        int iRet = 0;
        if( 0 == iPID )
        {
            phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "couldn't find tmm process!!!");
        }
        else
        {
            iRet = kill(iPID, 9);
            if( 0 == iRet )
            {
                phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "kill-9 tmm process with PID %d", iPID);
            }
            else
            {
                phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "cann't kill tmm process");
            }
        }
    }
    pclose(pShellKillTmm);

    /*break sequence run by sending SIGINT to ATE process*/
    /*get ATE server process id by popen*/
    memset(szPopenCMD, 0, MAX_SESSION_ID_LEN);
    sprintf(szPopenCMD, "ps -ef |grep [A]TE-server-process|grep %s|awk '{print $2}'", handlerID->p.szSession);

    FILE *pShellKillATE = popen(szPopenCMD, "r");
    char szResultATE[1024] = {0};
    if( NULL == pShellKillATE)
    {
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "popen failed!!!");
    }
    else
    {
        fgets(szResultATE, sizeof(szResultATE), pShellKillATE);
        int iPID = atoi(szResultATE);
        int iRet = 0;
        if( 0 == iPID )
        {
            phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "couldn't find ATE-server-process!!!");
        }
        else
        {
            iRet = kill(iPID, 2);
            if( 0 == iRet )
            {
                phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "kill-2 ATE-server-process with PID %d", iPID);
            }
            else
            {
                phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "cann't kill ATE-server-process");
            }
        }
    }
    pclose(pShellKillATE);

    usleep(200000);
    phTcomSetSystemFlag(handlerID->myTcom, PHTCOM_SF_CI_ABORT, 0);

    return;
#endif
}

/* create descriptive status string */
static char *statusString(phFuncId_t handlerID)
{
    static char statusMessage[1024];
    long status = handlerID->p.status;

    statusMessage[0] = '\0';

    if (status != 0L)
        sprintf(statusMessage, "last received handler status word: 0x%08lx, explanation:\n", status);
    else
        sprintf(statusMessage, "last received handler status word: 0x%08lx\n", status); 

    switch (handlerID->model)
    {
    case PHFUNC_MOD_GS1:
    case PHFUNC_MOD_M45:
    case PHFUNC_MOD_M48:
    case PHFUNC_MOD_DLT: /* DLT enhance*/
    /*Begin, Adam Huang, 29 JAN 2015*/
    case PHFUNC_MOD_YUSHAN: /* YUSHAN enhance*/
    /*End*/
        if (status & (1L << 0))
            strcat(statusMessage, "handler status: Loader sequence operating condition\n");
        if (status & (1L << 1))
            strcat(statusMessage, "handler status: Main sequence operating condition\n");
        if (status & (1L << 2))
            strcat(statusMessage, "handler status: High alarm occurrence condition\n");
        if (status & (1L << 3))
            strcat(statusMessage, "handler status: Low alarm occurrence condition\n");
        if (status & (1L << 4))
            strcat(statusMessage, "handler status: Loader empty occurrence condition\n");
        if (status & (1L << 5))
            strcat(statusMessage, "handler status: Handler empty occurrence condition\n");
        if (status & (1L << 6))
            strcat(statusMessage, "handler status: Temperature control button state\n");
        if (status & (1L << 7))
            strcat(statusMessage, "handler status: TEMP. stabilizing condition\n");
        if (status & (1L << 8))
            strcat(statusMessage, "handler status: TEMP. stabilized condition\n");
        if (status & (1L << 9))
            strcat(statusMessage, "handler status: Temperature alarm occurrence condition\n");
        if (status & (1L << 10))
            strcat(statusMessage, "handler status: Testing condition\n");
        if (status & (1L << 11))
            strcat(statusMessage, "handler status: During lot end sequence\n");
        if (status & (1L << 12))
            strcat(statusMessage, "handler status: Lot end\n");
        if (status & (1L << 13))
            strcat(statusMessage, "handler status: Lot last test\n");
        if (status & (1L << 14))
            strcat(statusMessage, "handler status: Controlling remote\n");
        if (status & (1L << 15))
            strcat(statusMessage, "handler status: Not used\n");
        break;
    default: 
        break;
    }

    return statusMessage;
}

/* analyze handler status word and write message, if not empty */
static void analyzeStatus(phFuncId_t handlerID, int warn)
{
    char *message = NULL;

    message = statusString(handlerID);

    phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "%s", message);

    if (handlerID->p.status != 0L && warn)
        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_WARNING,
                         "%s", message);
}

/* query handler's status and analyze it */
static phFuncError_t queryStatus(phFuncId_t handlerID, int warn)
{
    phFuncError_t retVal = PHFUNC_ERR_OK;
    static char status[512];

    switch (handlerID->model)
    {
    case PHFUNC_MOD_GS1:
    case PHFUNC_MOD_M45:
    case PHFUNC_MOD_M48:
    case PHFUNC_MOD_DLT: /*DLT enhance*/
    /*Begin, Adam Huang, 29 JAN 2015*/
    case PHFUNC_MOD_YUSHAN: /* YUSHAN enhance*/
    /*End*/
        PhFuncTaCheck(phFuncTaSend(handlerID, "HDLSTATUS?%s", handlerID->p.eol));
        retVal = phFuncTaReceive(handlerID, 1, "%511[^\n\r]", status);
        if (retVal != PHFUNC_ERR_OK)
        {
            phFuncTaRemoveStep(handlerID); 
            return retVal;
        }
        if (sscanf(status, "HDLSTATUS %lx", &handlerID->p.status) != 1)
        {
            phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_WARNING,
                             "status word not received from handler: \"%s\", trying again", status);
            phFuncTaRemoveStep(handlerID);
            phFuncTaRemoveStep(handlerID);
            return PHFUNC_ERR_WAITING;
        }

        analyzeStatus(handlerID, warn);
        break;
    default:
        break;
    }
    return retVal;
}


/* poll parts to be tested */
static phFuncError_t pollParts(phFuncId_t handlerID)
{
    phFuncError_t retVal = PHFUNC_ERR_OK;

    static char handlerAnswer[512] = "";
    unsigned long population;
    unsigned long populationPicked = 0L;
    int i;
    char* tempChr = 0;

    switch (handlerID->model)
    {
    case PHFUNC_MOD_GS1:
    case PHFUNC_MOD_M45:
    case PHFUNC_MOD_M48:
    case PHFUNC_MOD_DLT:  /*DLT enhance */
    /*Begin, Adam Huang, 29 JAN 2015*/
    case PHFUNC_MOD_YUSHAN: /* YUSHAN enhance*/
    /*End*/
        PhFuncTaCheck(phFuncTaSend(handlerID, "FULLSITES?%s", handlerID->p.eol));
        retVal = phFuncTaReceive(handlerID, 1, "%511[^\n\r]", handlerAnswer);
        if (retVal != PHFUNC_ERR_OK)
        {
            phFuncTaRemoveStep(handlerID); // force re-send of command
            return retVal;
        }

        break;
    default: break;
    }

    /* ensure string is in upper case */
    setStrUpper(handlerAnswer);

    /* check answer from handler, similar for all handlers.  remove
       two steps (the query and the answer) if an empty string was
       received */
    if (sscanf(handlerAnswer, "FULLSITES %lx", &population) != 1)
    {
        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR,
                         "site population not received from handler: \n"
                         "received \"%s\" format expected \"FULLSITES xxxxxxxx\" \n",
                         handlerAnswer);
        handlerID->p.oredDevicePending = 0;
        return PHFUNC_ERR_ANSWER;
    }

    tempChr = strchr(handlerAnswer, ' ')+1; 
    handlerID->p.fullsitesStrLen = strlen(tempChr);

    /* correct pending devices information, overwrite all (trust the
       last handler query) */
    handlerID->p.oredDevicePending = 0;
    for (i=0; i<handlerID->noOfSites; i++)
    {
        if (population & (1L << i))
        {
            handlerID->p.devicePending[i] = 1;
            handlerID->p.oredDevicePending = 1;
            phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, 
                             "device present at site \"%s\" (polled)", 
                             handlerID->siteIds[i]);
            populationPicked |= (1L << i);
        }
        else
        {
            handlerID->p.devicePending[i] = 0;
            phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, 
                             "no device at site \"%s\" (polled)", 
                             handlerID->siteIds[i]);
        }
    }

    /* check whether we have received too many parts */

    if (population != populationPicked)
    {
        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR, 
                         "The handler seems to present more devices than configured\n"
                         "The driver configuration must be changed to support more sites");
    }

    return retVal;
}

static phFuncError_t specialSRQHandling(phFuncId_t handlerID)
{
    unsigned long srqkind = 0;
    static char handlerAnswer[512] = "";

    PhFuncTaCheck(phFuncTaSend(handlerID, "SRQKIND?%s", handlerID->p.eol));
    PhFuncTaCheck(phFuncTaReceive(handlerID, 1, "%511[^\n\r]", handlerAnswer));

    setStrUpper(handlerAnswer);

    if (sscanf(handlerAnswer, "SRQKIND %lx", &srqkind) != 1)
    {
        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR,
                         "SRQKIND not received from handler: \n"
                         "received \"%s\" format expected \"SRQKIND xx\" \n",
                         handlerAnswer);
        return PHFUNC_ERR_ANSWER;
    }


    if (srqkind & 0x06)
    {
        if(srqkind & 0x02)
        {
            //phTcomSetModelfileString(handlerID->myTcom, "HANDLER_LOT_STATUS", "LOT_STARTED");
        }
        else
        {
            //phTcomSetModelfileString(handlerID->myTcom, "HANDLER_LOT_STATUS", "RETEST_LOT_STARTED");
        }

        /* lot start detected, send comfirmation to handler */
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "Lot start from handler detected...");
        PhFuncTaCheck(phFuncTaSend(handlerID, "LOTORDER 0%s", handlerID->p.eol));
        handlerID->p.lotStarted = 1;

        /* after the Lot start, just polling parts */
        PhFuncTaCheck(pollParts(handlerID));
        return PHFUNC_ERR_OK;
    }

    if (srqkind & 0x10)
    {
        /* lot end detected, send confirmation to handler */
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "Final lot end from handler detected...");

        PhFuncTaCheck(phFuncTaSend(handlerID, "LOTORDER 2%s", handlerID->p.eol));
        handlerID->p.lotStarted = 0;
        
        /* set final lot end flag to exit test program */
        finalLotEndFlag = 1;

        return PHFUNC_ERR_LOT_DONE;
    }

    if (srqkind & 0x08)
    {
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "Lot end from handler detected...");
        PhFuncTaCheck(phFuncTaSend(handlerID, "LOTRETESTCLEAR?", handlerID->p.eol));
        PhFuncTaCheck(phFuncTaReceive(handlerID, 1, "%511[^\n\r]", handlerAnswer));
        if ( strncmp(handlerAnswer, "LOTRETESTCLEAR", strlen("LOTRETESTCLEAR")) != 0)
        {
            phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_WARNING, "Answer is not expected, try again");
            phFuncTaRemoveStep(handlerID);
            phFuncTaRemoveStep(handlerID);
            return PHFUNC_ERR_WAITING;
        }
        else
        {
            PhFuncTaCheck(phFuncTaSend(handlerID, "LOTORDER 2%s", handlerID->p.eol));
            handlerID->p.lotStarted = 0;
            return PHFUNC_ERR_LOT_DONE;
        }
    }

    if (srqkind & 0x80)
    {
        /* double-test(reprobe) detected */
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "Double-test(reprobe) from handler detected...");
        /* just poll the parts */
        PhFuncTaCheck(pollParts(handlerID));
        return PHFUNC_ERR_OK;
    }

    return PHFUNC_ERR_OK;
}

/* wait for parts to be tested in general */
static phFuncError_t waitForParts(phFuncId_t handlerID)
{
    static int srq = 0;
    static int received = 0;
    static int printStartHandler = 0;

    struct timeval pollStartTime;
    struct timeval pollStopTime;
    int timeout;

    phFuncError_t retVal = PHFUNC_ERR_OK;

    if (printStartHandler == 0)
    {
        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_MESSAGE_0, "Push the START button on the handler...");
        printStartHandler = 1;
    }

    /* check if lot is started */
#if 0
    while (handlerID->p.lotStarted == 0)
    {
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "Waiting for lot start...");
        PhFuncTaCheck(phFuncTaTestSRQ(handlerID, &received, &srq, 0));
        phFuncTaRemoveStep(handlerID);

        if (received && (srq & 0x80))
        {
            /* special SRQ got */
            PhFuncTaCheck(specialSRQHandling(handlerID));
        }
    }
#endif

    if (handlerID->p.strictPolling)
    {
        /* before any polling, check SRQ to see if lot end is detected */
        PhFuncTaCheck(phFuncTaTestSRQ(handlerID, &received, &srq, 1));
        if (received && (srq & 0x80))
        {
            /* special SRQ got */
            PhFuncTaCheck(specialSRQHandling(handlerID));
        }

        /* apply strict polling loop, ask for site population */
        gettimeofday(&pollStartTime, NULL);

        timeout = 0;
        localDelay_us(handlerID->p.pollingInterval);
        do
        {
            PhFuncTaCheck(pollParts(handlerID));
            if (!handlerID->p.oredDevicePending)
            {
                gettimeofday(&pollStopTime, NULL);
                if ((pollStopTime.tv_sec - pollStartTime.tv_sec)*1000000L + 
                    (pollStopTime.tv_usec - pollStartTime.tv_usec) > 
                    handlerID->heartbeatTimeout)
                    timeout = 1;
                else
                    localDelay_us(handlerID->p.pollingInterval);
            }
        } while (!handlerID->p.oredDevicePending && !timeout);

        /* flush any pending SRQs, we don't care about them but want
               to eat them up. Otherwise reconfiguration to interrupt
               based mode would fail. */
        /* TBD PhFuncTaCheck(flushSRQs(handlerID)); */
    }
    else
    {
        /* we don't do strict polling, try to receive a start SRQ */
        /* this operation covers the heartbeat timeout only, if there
               are no more unexpected devices pending from a previous call
               (e.g. devices provided during reprobe) */
        PhFuncTaCheck(phFuncTaTestSRQ(handlerID, &received, &srq, handlerID->p.oredDevicePending));

        if (received)
        {
            switch (handlerID->model)
            {
            case PHFUNC_MOD_GS1:
            case PHFUNC_MOD_M45:
            case PHFUNC_MOD_M48:
            case PHFUNC_MOD_DLT: /*DLT enhance */
            /*Begin, Adam Huang, 29 JAN 2015*/
            case PHFUNC_MOD_YUSHAN: /* YUSHAN enhance*/
            /*End*/
                if ( srq & 0x03 )
                {
                    phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, 
                                     "received generic test start SRQ, need to poll");
                    /* test start srq will also set lotstart flag even there is no lot start signal received*/
                    handlerID->p.lotStarted = 1;
                    /* now there may be parts, but we don't know where,
                       must poll */
                    PhFuncTaCheck(pollParts(handlerID));
                }
                else if (srq & 0x80)
                {
                    /* special SRQ got */
                    PhFuncTaCheck(specialSRQHandling(handlerID));
                }
                else
                {
                    /* some exceptional SRQ occured */
                    phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_WARNING,
                                     "received exceptional SRQ 0x%02x:", srq);
                }
                break;
            default: break;
            }
        }
/* disable the poll, CR-91087 */
#if 0
        else
        {
            /* do one poll. Maybe there is a part here, but we have not
                   received an SRQ */
            phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, 
                             "have not received new devices through SRQ, try to poll...");
            PhFuncTaCheck(pollParts(handlerID));
            if (handlerID->p.oredDevicePending)
            {
                /* flush any pending SRQs that may have occured 
                   during population query */
                /* TBD PhFuncTaCheck(flushSRQs(handlerID)); */
            }
        }
#endif
    }

    return retVal;
}

/*****************************************************************************
 *
 * Setup bin code
 *
 * Description:
 *   For given bin information setup correct binCode.
 *
 ***************************************************************************/
static phFuncError_t setupBinCode(
                                 phFuncId_t handlerID     /* driver plugin ID */,
                                 long binNumber            /* for bin number */,
                                 char *binCode             /* array to setup bin code */
                                 )
{
    phFuncError_t retVal = PHFUNC_ERR_OK;
    int binInt = 0;
    char tempBinCode[10] = "";

    strcpy(binCode,"");

    if (handlerID->binIds)
    {
        /* if handler bin id is defined (hardbin/softbin mapping), get the bin code from the bin id list*/
        strcpy(tempBinCode, handlerID->binIds[binNumber]);
    }
    else
    {
        /* if handler bin id is not defined (default mapping), use the bin number directly */
        sprintf(tempBinCode, "%ld", binNumber);
    }

    /* make the bin code in the GPIB  binning command */
    if (strcmp(tempBinCode, RETEST_BIN_IN_HANDLER) == 0 || strcmp(tempBinCode, "-1") == 0)
    {
       /* retest bin */
       sprintf(binCode,"%s",RETEST_BIN_IN_MSG);
    }
    else
    {
        /* normal bins */
        sscanf(tempBinCode, "%d", &binInt);
        if (binInt <= 9)
        {
            sprintf(binCode, "%d", binInt );
        }
        else
        {
            if ( (handlerID->p.binningCommandFormat == 16))
            {
                //check if the handler bin id is legal or not 
                if (binInt > 16)
                {
                    phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR,
                                     "Invalid binning data.\n"
                                     "Could not bin to handler bin %ld. \n"
                                     "The max bin code allowed for 16-bin configuration is 16!",
                                      binInt);
                    return PHFUNC_ERR_BINNING;
                }

                /* For 16 bin configuration:
                 * Bin code in Binning Command: 0 1 2 3 4 5 6 7 8 9 A B  C  D  E  F  G  H
                 * Real bin code in handler:    0 1 2 3 4 5 6 7 8 9 R 10 11 12 13 14 15 16
                 * R means retest bin.
                 */
                sprintf(binCode, "%c", (char)(0x37 +  (binInt+1)) );
                phLogFuncMessage(handlerID->myLogger, LOG_DEBUG,
                                 "in order to send binning message, translate bin code from %d to \"%s\" (16-bin binning command)  ",
                                 binInt, binCode);

            }
            else
            {
                /* For 32 bin configuration
                 * Bin code in Binning Command: 0 1 2 3 4 5 6 7 8 9 A B  C  D  E  F  10 11 ... 20 21
                 * Real bin code in handler:    0 1 2 3 4 5 6 7 8 9 R 10 11 12 13 14 15 16 ... 31 32
                 * R means retest bin.
                 */
                sprintf(binCode, "%lx", (long unsigned int)(binInt+1));
                phLogFuncMessage(handlerID->myLogger, LOG_DEBUG,
                                 "in order to send binning message, translate bin code from %d to \"%s\" (32-bin binning command)  ",
                                 binInt, binCode);
            }
        }
    }

    if(handlerID->binIds)
    {
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, 
                         "handler_bin_ids is defined and handler_bin_ids[%ld]=\"%s\". In the GPIB command, \"%s\" is used as bin ID.",
                         binNumber, tempBinCode, binCode);
    }
    else
    {
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, 
                         "handler_bin_ids NOT defined, using hardbin number %ld directly. In the GPIB command, \"%s\" is used as bin ID.",
                         binNumber, binCode);
    }

    return retVal;
}

/*****************************************************************************
 *
 * Compare bin information between the sent binning command
 * and the received echoed binning information.
 *
 * format of each string for 16 bin (0-9 and A-H) configuration: 
 *   BINON: XXXXXXXX,XXXXXXXX,XXXXXXXX,XXXXXXXX;  (sent)
 *    ECHO: XXXXXXXX,XXXXXXXX,XXXXXXXX,XXXXXXXX;  (received)
 * X=0 to 9 and A to H; 
 * 
 * the format of each string is as follows (32 categories ):
 *   BINON: X,X,X,X,...,X,X,X,X; (sent)
 *   ECHO:  X,X,X,X,...,X,X,X,X; (received)
 * X=0 to 21 (hexadecimal number)
 *
 ***************************************************************************/
static phFuncError_t checkBinningInformation(
                                            phFuncId_t handlerID     /* driver plugin ID */,
                                            const char *sent         /* sent binning command */,
                                            const char *received     /* returned binning info */
                                            )
{
    phFuncError_t retVal = PHFUNC_ERR_OK;
    const char* s=sent;
    const char* r=received;
    int checkError = 0;

    /* find first colon */
    s=strchr(s,':');
    r=strchr(r,':');

    if (s==NULL || r==NULL || strlen(s) != strlen(r))
    {
        checkError = 1;
    }
    else
    {
        while ( *s && *r )
        {
            if ( tolower(*s) != tolower(*r) )
            {
                checkError = 1;
                break;
            }
            ++s;
            ++r;
        }
    }

    if ( checkError == 1 )
    {
        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR,
                         "difference found between sent and returned binning information \n"
                         "SENT:    \"%s\"\n"
                         "RECEIVED: \"%s\"",sent,received);
        retVal = PHFUNC_ERR_BINNING;
    }

    return retVal;
}


/* create and send bin and reprobe information information */
static phFuncError_t binAndReprobe(
                                  phFuncId_t handlerID     /* driver plugin ID */,
                                  phEstateSiteUsage_t *oldPopulation /* current site population */,
                                  long *perSiteReprobe     /* TRUE, if a device needs reprobe*/,
                                  long *perSiteBinMap      /* valid binning data for each site where
                                                              the above reprobe flag is not set */
                                  )
{
    phFuncError_t retVal = PHFUNC_ERR_OK;

    char testresults[PHESTATE_MAX_SITES*2 + 512];
    char tmpCommand[256] = {0};
    static char querybins[PHESTATE_MAX_SITES*2 + 512];
    char thisbin[32];
    int i;
    int sendBinning = 0;
    static int retryCount = 0;
    int repeatBinning = 0;
    int maxNoOfSiteInCmd = 0;

    do
    {
        retVal = PHFUNC_ERR_OK;

        phFuncTaMarkStep(handlerID);

        switch (handlerID->model)
        {
        case PHFUNC_MOD_GS1:
        case PHFUNC_MOD_M45:
        case PHFUNC_MOD_M48:
        case PHFUNC_MOD_DLT: /*DLT enhance */
        /*Begin, Adam Huang, 29 JAN 2015*/
        case PHFUNC_MOD_YUSHAN: /* YUSHAN enhance*/
        /*End*/
            strcpy(testresults, handlerID->p.verifyBins?"BINON:":"BINOFF:");

            /*
             * The site number in the BINON/BINOFF command should match the
             * site number returns from the FULLSITES command where even there
             * are less sites configed in both the handler and driver. Otherwise
             * the handler may report alarms.
             */
            if (handlerID->p.fullsitesStrLen*4 > PHESTATE_MAX_SITES)
            {
                maxNoOfSiteInCmd = PHESTATE_MAX_SITES;
            }
            else
            {
                maxNoOfSiteInCmd = handlerID->p.fullsitesStrLen*4;
            }

            for ( i=maxNoOfSiteInCmd - 1; i>=0 && i<PHESTATE_MAX_SITES && retVal==PHFUNC_ERR_OK ; --i )
            {
                if ( handlerID->activeSites[i] && 
                     (oldPopulation[i] == PHESTATE_SITE_POPULATED ||
                      oldPopulation[i] == PHESTATE_SITE_POPDEACT) )
                {
                    /* there is a device here */
                    if (perSiteReprobe && perSiteReprobe[i])
                    {
                        if ( !handlerID->p.reprobeBinDefined )
                        {
                            /* no reprobe bin number defined */
                            phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_FATAL,
                                             "received reprobe command at site \"%s\" but no reprobe bin number defined \n"
                                             "please check the configuration values of \"%s\" and \"%s\"",
                                             handlerID->siteIds[i], PHKEY_RP_AMODE, PHKEY_RP_BIN);
                            retVal =  PHFUNC_ERR_BINNING;
                        }
                        else
                        {
                            /* reprobe this one */
                            if (handlerID->p.reprobeBinNumber <= 9)
                            {
                                //sprintf(tmpCommand, "%c", (char)(0x30 +  handlerID->p.reprobeBinNumber) );
                                sprintf(tmpCommand, "%d", handlerID->p.reprobeBinNumber );
                            }
                            else
                            {
                                if ( (handlerID->p.binningCommandFormat == 16))
                                {
                                    /* For 16 bin configuration:
                                     * Bin code in Binning Command: 0 1 2 3 4 5 6 7 8 9 A B  C  D  E  F  G  H
                                     * Real bin code in handler:    0 1 2 3 4 5 6 7 8 9 R 10 11 12 13 14 15 16
                                     * R means retest bin. 
                                     */
                                    sprintf(tmpCommand, "%c", (char)(0x38 +  handlerID->p.reprobeBinNumber) );
                                }
                                else
                                {
                                    /* For 32 bin configuration
                                     * Bin code in Binning Command: 0 1 2 3 4 5 6 7 8 9 A B  C  D  E  F  10 11 ... 20 21
                                     * Real bin code in handler:    0 1 2 3 4 5 6 7 8 9 R 10 11 12 13 14 15 16 ... 31 32
                                     * R means retest bin.
                                     */
                                    sprintf(tmpCommand, "%lx", (long unsigned int)(handlerID->p.reprobeBinNumber+1));
                                }
                            }
                        }
                        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG,
                                         "will reprobe device at site \"%s\"",
                                         handlerID->siteIds[i]);
                        strcat(testresults, tmpCommand);
                        sendBinning = 1;
                    }
                    else
                    {
                        retVal=setupBinCode(handlerID, perSiteBinMap[i], thisbin);
                        if ( retVal==PHFUNC_ERR_OK )
                        {
                            strcat(testresults, thisbin);
                            phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, 
                                             "will bin device at site \"%s\" to %s", 
                                             handlerID->siteIds[i], thisbin);
                            sendBinning = 1;
                        }
                        else
                        {
                            phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR, 
                                             "unable to send binning at site \"%s\"", 
                                             handlerID->siteIds[i]);
                            sendBinning = 0;
                        }
                    }
                }
                else
                {
                    /* there's not a device here */
                    strcat(testresults, NO_BINNING_RESULT);
                    if ( i < handlerID->noOfSites )
                    {
                        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG,
                                         "no device to bin at site \"%s\"", 
                                         handlerID->siteIds[i]);
                    }
                }

                if ( i == 0 )
                {
                    strcat(testresults, ";");
                }
                else if ( (handlerID->p.binningCommandFormat == 32) || 
                          (handlerID->p.binningCommandFormat == 16 && i % 8 == 0) )
                {
                    strcat(testresults, ",");
                }
            }
            if (sendBinning)
            {
                PhFuncTaCheck(phFuncTaSend(handlerID, "%s%s", testresults, handlerID->p.eol));
            }
            break;
        default: break;
        }

        /* verify binning, if necessary */
        if (handlerID->p.verifyBins && sendBinning)
        {
            phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, 
                             "will perform bin verification ....");
            PhFuncTaCheck(phFuncTaReceive(handlerID, 1, "%511[^\n\r]", querybins));

            retVal=checkBinningInformation(handlerID, testresults, querybins);

            if (retVal == PHFUNC_ERR_OK)
            {
                phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, 
                                 ".... verification succeeded");
                PhFuncTaCheck(phFuncTaSend(handlerID, "ECHOOK%s", 
                                           handlerID->p.eol));
            }
            else
            {
                phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, 
                                 ".... verification failed");
                PhFuncTaCheck(phFuncTaSend(handlerID, "ECHONG%s", 
                                           handlerID->p.eol));
            }
        }

        /* in case of receiving bad bin data during verification, we may want to try again */
        retryCount++;

        repeatBinning = (retVal == PHFUNC_ERR_BINNING &&
                         retryCount <= handlerID->p.verifyMaxCount &&
                         handlerID->p.verifyBins && 
                         sendBinning);

        if (repeatBinning)
        {
            repeatBinning = 1;
            phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR,
                             "will try to send bin data %d more time(s) before giving up",
                             1 + handlerID->p.verifyMaxCount - retryCount);

            /* we do a loop, now go back to stored interaction mark */
            phFuncTaRemoveToMark(handlerID);    
        }

    } while (repeatBinning);

    retryCount = 0;

    return retVal;
}

/* send verification mode, if necessary */
static phFuncError_t reconfigureVerification(phFuncId_t handlerID)
{
    int found = 0;
    phConfError_t confError;
    phFuncError_t retVal = PHFUNC_ERR_OK;
    double dRetryCount;

    /* look for the verification request */
    confError = phConfConfStrTest(&found, handlerID->myConf,
                                  PHKEY_BI_VERIFY, "yes", "no", NULL);
    if (confError != PHCONF_ERR_UNDEF && confError != PHCONF_ERR_OK)
        retVal = PHFUNC_ERR_CONFIG;
    else
    {
        switch (found)
        {
        case 1:
            /* configured "yes" */
            switch (handlerID->model)
            {
            case PHFUNC_MOD_GS1:
            case PHFUNC_MOD_M45:
            case PHFUNC_MOD_M48:
            case PHFUNC_MOD_DLT: /*DLT enhance */
            /*Begin, Adam Huang, 29 JAN 2015*/
            case PHFUNC_MOD_YUSHAN: /* YUSHAN enhance*/
            /*End*/
                phLogFuncMessage(handlerID->myLogger, LOG_DEBUG,
                                 "will activate bin verification mode");
                handlerID->p.verifyBins = 1;
                break;
            default: break;
            }
            break;
        case 2:
            /* configured "no" */
            switch (handlerID->model)
            {
            case PHFUNC_MOD_GS1:
            case PHFUNC_MOD_M45:
            case PHFUNC_MOD_M48:
            case PHFUNC_MOD_DLT:   /*DLT enhance */
            /*Begin, Adam Huang, 29 JAN 2015*/
            case PHFUNC_MOD_YUSHAN: /* YUSHAN enhance*/
            /*End*/
                phLogFuncMessage(handlerID->myLogger, LOG_DEBUG,
                                 "will deactivate bin verification mode");
                handlerID->p.verifyBins = 0;
                break;
            default: break;
            }
            break;
        default:
            /* not configured, assume bin verification is not set up */
            phLogFuncMessage(handlerID->myLogger, LOG_DEBUG,
                             "\"%s\" not set: assume no bin verification",
                             PHKEY_BI_VERIFY);
            handlerID->p.verifyBins = 0;
            break;
        }
    }

    /* look for the maximum verification count */
    confError = phConfConfIfDef(handlerID->myConf, PHKEY_BI_VERCOUNT);
    if (confError == PHCONF_ERR_OK)
        confError = phConfConfNumber(handlerID->myConf, PHKEY_BI_VERCOUNT, 
                                     0, NULL, &dRetryCount);
    if (confError == PHCONF_ERR_OK)
        handlerID->p.verifyMaxCount = (int) dRetryCount;
    else
    {
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG,
                         "\"%s\" not set: assume double retry",
                         PHKEY_BI_VERCOUNT);
        handlerID->p.verifyMaxCount = 2; /* default double retry */
    }

    return retVal;
}

/* check handler is running */
static phFuncError_t checkHandlerRunning(
                                        phFuncId_t handlerID         /* driver plugin ID */,
                                        char **handlerRunningString  /* resulting pointer to running query string */
                                        )
{
    static char frQuery[512] = "";

    //reset the value
    frQuery[0] = '\0';

    phFuncError_t retVal = PHFUNC_ERR_OK;

    //return the string address
    *handlerRunningString = frQuery;



    /* no identification but may ask if handler is running */
    PhFuncTaCheck(phFuncTaSend(handlerID, "FR?%s", handlerID->p.eol));
    localDelay_us(100000);

    retVal = phFuncTaReceive(handlerID, 1, "%511[^\n\r]", frQuery);

    if (retVal != PHFUNC_ERR_OK)
    {
        phFuncTaRemoveStep(handlerID); 
        return retVal;
    }

    localDelay_us(100000);

    return retVal;
}

static phFuncError_t handlerSetup(
                                 phFuncId_t handlerID    /* driver plugin ID */
                                 )
{
    phFuncError_t retVal = PHFUNC_ERR_OK;

    switch (handlerID->model)
    {
    case PHFUNC_MOD_GS1:
    case PHFUNC_MOD_M45:
    case PHFUNC_MOD_M48:
    case PHFUNC_MOD_DLT: /*DLT enhance */
    /*Begin, Adam Huang, 29 JAN 2015*/
    case PHFUNC_MOD_YUSHAN: /* YUSHAN enhance*/
    /*End*/
        /* set command delimiter */
        PhFuncTaCheck(phFuncTaSend(handlerID, "DL 0%s", handlerID->p.eol));

        /* set SRQ output */
#if 0
        if (handlerID->p.strictPolling == 1)
        {
            PhFuncTaCheck(phFuncTaSend(handlerID, "SRQ 0%s", handlerID->p.eol));
        }
        else
        {
            PhFuncTaCheck(phFuncTaSend(handlerID, "SRQ 1%s", handlerID->p.eol));
        }
#endif

        /* set SRQMASK */
        PhFuncTaCheck(phFuncTaSend(handlerID, "SRQMASK %s%s", handlerID->p.srqMask, handlerID->p.eol));


        break;
    default:
        break;
    }


    /* TBD: flush any pending SRQs (will poll later, if we are missing some
       test start SRQ here */
    /* PhFuncTaCheck(flushSRQs(handlerID)); */

    return retVal;
}

/* perform the real reconfiguration */
static phFuncError_t doReconfigure(phFuncId_t handlerID)
{
    phFuncError_t retVal = PHFUNC_ERR_OK;
    int found = 0;
    int listLength = 0;     /* length of thermal alarm srq list */
    int iLoop = 0;          /* loop control */
    phConfError_t confError;
    phConfType_t defType;   /* the type of configuration */
    double dSRQ = 0;        /* value of configured srq */
    double dPollingInterval;
    double dReprobeBinNumber;
    char szLogMsg[256] = {0};   /* log msg */
    char *handlerRunning = NULL;
    const char *srqMask = NULL;
    const char *binningCommandFormat = NULL;
    static int firstTime=1;
    unsigned long srqMaskLong = 0;

    /* chose polling or SRQ interrupt mode */
    phConfConfStrTest(&found, handlerID->myConf, PHKEY_FC_WFPMODE, 
                      "polling", "interrupt", NULL);
    if (found == 1)
    {
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG,
                         "activated strict polling mode, no SRQ handling");
        handlerID->p.strictPolling = 1;
    }
    else
    {
        /* default */
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG,
                         "activated SRQ based device handling");
        handlerID->p.strictPolling = 0;
    }

    /* retrieve srqmask */
    confError = phConfConfIfDef(handlerID->myConf, PHKEY_SU_SRQMASK);
    if (confError == PHCONF_ERR_OK)
        confError = phConfConfString(handlerID->myConf, PHKEY_SU_SRQMASK,
                                     0, NULL, &srqMask);
    memset(handlerID->p.srqMask, 0, 4);
    if (confError == PHCONF_ERR_OK)
    {
        strncpy(handlerID->p.srqMask, srqMask, 2);
    }
    else
    {
        strcpy(handlerID->p.srqMask, "FF"); /* default FF*/
    }
    phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "Set SRQMASK to %s", handlerID->p.srqMask);
    sscanf(handlerID->p.srqMask, "%lx", &srqMaskLong);
    if (!(srqMaskLong & 0x06))
    {
        /* if the lot start/retest lot start bit in status byte is disabled, */
        /* assume the lot is started */
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "Lot start bits are masked, so assume lot is already started");
        handlerID->p.lotStarted = 1;
    }

    /* retrieve the advantest_binnng_command_format */
    confError = phConfConfIfDef(handlerID->myConf, PHKEY_PL_ADVANTEST_BINNING_COMMAND_FORMAT);
    if (confError == PHCONF_ERR_OK)
        confError = phConfConfString(handlerID->myConf, PHKEY_PL_ADVANTEST_BINNING_COMMAND_FORMAT,
                                     0, NULL, &binningCommandFormat);
    if (confError == PHCONF_ERR_OK)
    {
        if(strcmp(binningCommandFormat, "16-bin") == 0)
        {
            handlerID->p.binningCommandFormat = 16;
        }
        else if(strcmp(binningCommandFormat, "32-bin") == 0)
        {
            handlerID->p.binningCommandFormat = 32;
        }
        else
        {
            handlerID->p.binningCommandFormat = 16;
        }
    }
    else
    {
        handlerID->p.binningCommandFormat = 16; /* default 16-bin format*/
    }

    /* retrieve thermal alarm srq list */
    if( PHFUNC_MOD_GS1 == handlerID->model)
    {
        confError = phConfConfIfDef(handlerID->myConf, PHKEY_SU_THERMAL_ALARM_SRQ_LIST);
        if (confError == PHCONF_ERR_OK)
        {
            confError = phConfConfType(handlerID->myConf, PHKEY_SU_THERMAL_ALARM_SRQ_LIST, 0, NULL, &defType, &listLength);
            if (confError != PHCONF_ERR_OK || defType != PHCONF_TYPE_LIST || listLength > 10 || listLength <1 )
            {
                /* type error or list length error */
                phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR,
                        "phConfConfType(), the thermal alarm srq list is invalid, please check the configuration values of \"%s\"", PHKEY_SU_THERMAL_ALARM_SRQ_LIST);
                retVal = PHFUNC_ERR_CONFIG;
            }
            else
            {
                for (iLoop=0; iLoop<listLength; iLoop++)
                {
                    /* get the list value one by one */
                    confError = phConfConfNumber(handlerID->myConf, PHKEY_SU_THERMAL_ALARM_SRQ_LIST, 1, &iLoop, &dSRQ);
                    if (confError != PHCONF_ERR_OK)
                    {
                        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR,
                                "phConfConfNumber(), the thermal alarm srq list is invalid, please check the configuration values of \"%s\"", PHKEY_SU_THERMAL_ALARM_SRQ_LIST);
                        retVal = PHFUNC_ERR_CONFIG;
                    }
                    else
                    {
                        /* register the call back function for thermal alarm SRQs */
                        handlerID->p.thermalAlarmSRQList[iLoop] = (int)dSRQ;
                        phComGpibRegisterSRQCallback( handlerID->myCom, 
                                (unsigned char)(handlerID->p.thermalAlarmSRQList[iLoop]),
                                (AsyncSRQCallback_t)asyncSRQCallback, 
                                0, 
                                (void*)handlerID ); 
                        sprintf(szLogMsg, "%s 0x%x", szLogMsg, handlerID->p.thermalAlarmSRQList[iLoop]);
                    }
                }
                phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_MESSAGE_0, "Thermal Alarm SRQ configured as%s", szLogMsg);
            }
        }
        else
        {
            /* the themal alarm srq must be defined in configuration file */
            phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR,
                    "phConfConfIfDef(), the thermal alarm srq list must be defined in configuration file");
            retVal = PHFUNC_ERR_CONFIG;
        }
    }

    /* retrieve polling interval */
    confError = phConfConfIfDef(handlerID->myConf, PHKEY_FC_POLLT);
    if (confError == PHCONF_ERR_OK)
        confError = phConfConfNumber(handlerID->myConf, PHKEY_FC_POLLT, 
                                     0, NULL, &dPollingInterval);
    if (confError == PHCONF_ERR_OK)
        handlerID->p.pollingInterval = labs((long) dPollingInterval);
    else
    {
        handlerID->p.pollingInterval = 200000L; /* default 0.2 sec */
    }


    /* do we want to pause the handler ? */
    handlerID->p.pauseHandler = 0;
    confError = phConfConfStrTest(&found, handlerID->myConf, PHKEY_OP_PAUPROB, "yes", "no", NULL);
    if (confError != PHCONF_ERR_UNDEF && confError != PHCONF_ERR_OK)
    {
        retVal = PHFUNC_ERR_CONFIG;
    }
    else
    {
        if (found == 1)
        {
            phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "will pause handler on SmarTest pause");
            handlerID->p.pauseHandler = 1;
        }
    }

    /*
     * get reprobe bin number
     * following answers to queries from Advantest it appears the
     * the reprobe command could be set-up at the handler for any
     * of the possible bins: this number should be set as a
     * configuration variable
     */
    confError = phConfConfIfDef(handlerID->myConf, PHKEY_RP_BIN);
    if (confError == PHCONF_ERR_OK)
    {
        confError = phConfConfNumber(handlerID->myConf, PHKEY_RP_BIN,
                                     0, NULL, &dReprobeBinNumber);
    }
    if (confError == PHCONF_ERR_OK)
    {
        handlerID->p.reprobeBinDefined = 1;
        handlerID->p.reprobeBinNumber = abs((int) dReprobeBinNumber);
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG,
                         "configuration \"%s\" set: will send BIN %d command upon receiving a reprobe",
                         PHKEY_RP_BIN,
                         handlerID->p.reprobeBinNumber);
    }
    else
    {
        handlerID->p.reprobeBinDefined = 0;
        handlerID->p.reprobeBinNumber = 0;
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG,
                         "configuration \"%s\" not set: ignore reprobe command",
                         PHKEY_RP_BIN);
    }

    phConfConfStrTest(&found, handlerID->myConf, PHKEY_RP_AMODE,
                      "off", "all", "per-site", NULL);
    if ( (found==2 || found==3) && !handlerID->p.reprobeBinDefined )
    {
        /* frame work may send reprobe command but a reprobe bin has not been defined */
        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR,
                         "a reprobe mode has been defined without its corresponding bin number\n"
                         "please check the configuration values of \"%s\" and \"%s\"",
                         PHKEY_RP_AMODE, PHKEY_RP_BIN);
        retVal = PHFUNC_ERR_CONFIG;
    }

    /* perform the communication intesive parts */
    if ( firstTime )
    {
        PhFuncTaCheck(checkHandlerRunning(handlerID, &handlerRunning));


        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG,
                         "FR? handler running returns \"%s\" ",
                         handlerRunning);
        PhFuncTaCheck(handlerSetup(handlerID));

        firstTime=0;
    }
    PhFuncTaCheck(reconfigureVerification(handlerID));
    return retVal;
}


#ifdef INIT_IMPLEMENTED
/*****************************************************************************
 *
 * Initialize handler specific plugin
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *
 * Handler specific implementation of the corresponding plugin function
 * as defined in ph_hfunc.h
 ***************************************************************************/
phFuncError_t privateInit(
                         phFuncId_t handlerID      /* the prepared driver plugin ID */
                         )
{
    /*set environment variable to directly call set_sysflag_i_nomsg()*/
    if( setenv("SET_SYSTEMFLAG_NOMSG", "TRUE", 1) == -1 )
    {
        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR, "Failed to set SET_SYSTEMFLAG_NOMSG environment value!");
        return PHFUNC_ERR_ABORTED;
    }

    /*register signal for dummy thermal alarm*/
    /*returns the previous behavior of the signal SIGUSR1 and register the current behavior*/
    preSignalHandler = signal(SIGUSR1, dummyThermalAlarm);
    /*we do not care the return value of remove(), just to ensure there is no tmp file*/
    //remove("DUMMY_THERMAL_ALARM_FILE");
    if( 0!=remove("DUMMY_THERMAL_ALARM_FILE"))
    {
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG,
                "the file \"/tmp/DummyThermalAlarm.tmp\" cannot be deleted, please delete it manually");
    }

    phFuncError_t retVal = PHFUNC_ERR_OK;
    int i;

    /*init session name*/
    char *sz_session = NULL;
    sz_session = getenv("HP83000_DISPLAY");
    if (NULL == sz_session)
    {
        sz_session = getenv("DISPLAY");
    }
    memset(handlerID->p.szSession, 0, MAX_SESSION_ID_LEN);
    if(sz_session != NULL)
        strncpy(handlerID->p.szSession, sz_session, MAX_SESSION_ID_LEN-1);

    /*init thermal alarm flag*/
    thermalAlarmFlag = 0;

    /* abort in case of unsuccessful retry */
    if (phFuncTaAskAbort(handlerID))
        return PHFUNC_ERR_ABORTED;

    /* do some really initial settings */
    handlerID->p.sites = handlerID->noOfSites;
    for (i=0; i<handlerID->p.sites; i++)
    {
        handlerID->p.siteUsed[i] = handlerID->activeSites[i];
        handlerID->p.devicePending[i] = 0;
        handlerID->p.deviceExpected[i] = 0;
    }
    handlerID->p.verifyBins = 0;
    handlerID->p.verifyMaxCount = 0;

    handlerID->p.strictPolling = 0;
    handlerID->p.pollingInterval = 200000L;
    handlerID->p.oredDevicePending = 0;
    handlerID->p.status = 0L;
    handlerID->p.paused = 0;

    handlerID->p.lotStarted = 0;
    handlerID->p.fullsitesStrLen = 0;

    handlerID->p.binningCommandFormat = 16;

    strcpy(handlerID->p.eol, "\r\n");

    /* assume, that the interface was just opened and cleared, so
       wait 1 second to give the handler time to be reset the
       interface */
    sleep(1);

   handlerIDForThermalAlarmSimulation = handlerID;
   return retVal;
}
#endif


#ifdef RECONFIGURE_IMPLEMENTED
/*****************************************************************************
 *
 * reconfigure driver plugin
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *
 * Handler specific implementation of the corresponding plugin function
 * as defined in ph_hfunc.h
 ***************************************************************************/
phFuncError_t privateReconfigure(
                                phFuncId_t handlerID     /* driver plugin ID */
                                )
{
    phFuncError_t retVal = PHFUNC_ERR_OK;

    /* abort in case of unsuccessful retry */
    if (phFuncTaAskAbort(handlerID))
        return PHFUNC_ERR_ABORTED;

    phFuncTaStart(handlerID);
    PhFuncTaCheck(doReconfigure(handlerID));
    phFuncTaStop(handlerID);

    return retVal;
}
#endif


#ifdef RESET_IMPLEMENTED
/*****************************************************************************
 *
 * reset the handler
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *
 * Handler specific implementation of the corresponding plugin function
 * as defined in ph_hfunc.h
 ******************r*********************************************************/
phFuncError_t privateReset(
                          phFuncId_t handlerID     /* driver plugin ID */
                          )
{
    /* by default not implemented */
    ReturnNotYetImplemented("privateReset");
}
#endif


#ifdef DRIVERID_IMPLEMENTED
/*****************************************************************************
 *
 * return the driver identification string
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *
 * Handler specific implementation of the corresponding plugin function
 * as defined in ph_hfunc.h
 ***************************************************************************/
phFuncError_t privateDriverID(
                             phFuncId_t handlerID     /* driver plugin ID */,
                             char **driverIdString    /* resulting pointer to driver ID string */
                             )
{
    /* the resulting Id String is already composed by the code in
       ph_hfunc.c. We don't need to do anything more here and just
       return with OK */

    return PHFUNC_ERR_OK;
}
#endif



#ifdef EQUIPID_IMPLEMENTED
/*****************************************************************************
 *
 * return the handler identification string
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *
 * Handler specific implementation of the corresponding plugin function
 * as defined in ph_hfunc.h
 ***************************************************************************/
phFuncError_t privateEquipID(
                            phFuncId_t handlerID     /* driver plugin ID */,
                            char **equipIdString     /* resulting pointer to equipment ID string */
                            )
{
    static char idString[512] = "";
    static char resultString[1024] = "";
    idString[0] = '\0';
    *equipIdString = idString;
    phFuncError_t retVal = PHFUNC_ERR_OK;

    /* abort in case of unsuccessful retry */
    if (phFuncTaAskAbort(handlerID))
    {
        return PHFUNC_ERR_ABORTED;
    }

    phFuncTaStart(handlerID);
    PhFuncTaCheck(phFuncTaSend(handlerID, "VERSION?%s", handlerID->p.eol));
    retVal = phFuncTaReceive(handlerID, 1, "%s", idString);
    if (retVal != PHFUNC_ERR_OK)
    {
        phFuncTaRemoveStep(handlerID); 
        return retVal;
    }

    phFuncTaStop(handlerID);

    sprintf(resultString, "%s", idString);

    /* strip of white space at the end of the string */
    while (strlen(resultString) > 0 && isspace(resultString[strlen(resultString)-1]))
    {
        resultString[strlen(resultString)-1] = '\0';
    }

    return retVal;
}
#endif



#ifdef GETSTART_IMPLEMENTED
/*****************************************************************************
 *
 * Step to next device
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *
 * Handler specific implementation of the corresponding plugin function
 * as defined in ph_hfunc.h
 ***************************************************************************/
phFuncError_t privateGetStart(
                             phFuncId_t handlerID      /* driver plugin ID */
                             )
{
    /*set Deivce ID reload flag*/
    deviceIDReloadFlag = 1;

    /*themal alram judement*/
    if( 1 == thermalAlarmFlag ) {
        char response[128] = {0};
        const char* answer = NULL;
        int length = 0;
        char overtempSites[PHCOM_MAX_MESSAGE_LENGTH+1] = "";
        char currentAlarm[PHCOM_MAX_MESSAGE_LENGTH+1] = "";
        char logMsg[256] = {0};

        /* query current alarm message number */
        if(phComGpibSend(handlerID->myCom, (char*)"CURRENTALM?", strlen("CURRENTALM?"), handlerID->heartbeatTimeout) == PHCOM_ERR_OK)
        {
            if(phComGpibReceive(handlerID->myCom, &answer, &length, handlerID->heartbeatTimeout) == PHCOM_ERR_OK)
            {
                sscanf(answer, "current alarm msessage: %s", currentAlarm); 
                answer = NULL;
            }
        }

        /* query the overtemp sites */
        if(phComGpibSend(handlerID->myCom, (char*)"OVERTEMP?", strlen("OVERTEMP?"), handlerID->heartbeatTimeout) == PHCOM_ERR_OK)
        {
            if(phComGpibReceive(handlerID->myCom, &answer, &length, handlerID->heartbeatTimeout) == PHCOM_ERR_OK)
            {
                sscanf(answer, "OVERTEMP %s", overtempSites); 
                answer = NULL;
            }
        }

        sprintf(logMsg, "Thermal Alarm occured on the following sites: %s.\nCurrent Alarm message: %s.\nTest program is aborted!\n", overtempSites, currentAlarm);
        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_MESSAGE_1, logMsg);

        /* warning dialog */
        phGuiShowOptionDialog(handlerID->myLogger, PH_GUI_WARN_MESSAGE, logMsg, response);

        /* abort test program */
        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_MESSAGE_0, "Abort flag is set due to Thermal Alarm");
        phTcomSetSystemFlag(handlerID->myTcom, PHTCOM_SF_CI_ABORT, 1);

        /*reset thermal alarm flag*/
        thermalAlarmFlag = 0;
    }

    phFuncError_t retVal = PHFUNC_ERR_OK;
    int i;
    phEstateSiteUsage_t population[PHESTATE_MAX_SITES];

    /* abort in case of unsuccessful retry */
    if (phFuncTaAskAbort(handlerID))
        return PHFUNC_ERR_ABORTED;

    /* remember which devices we expect now */
    for (i=0; i<handlerID->noOfSites; i++)
        handlerID->p.deviceExpected[i] = handlerID->activeSites[i];

    phFuncTaStart(handlerID);

    phFuncTaMarkStep(handlerID);

    if (!handlerID->p.oredDevicePending)
    {
        /* no devices, need to poll */
        PhFuncTaCheck(waitForParts(handlerID));
    }
    else
    {
        /* device has already got, do not need to poll */
        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_MESSAGE_0, "device has already got, do not need to poll");
    }

    /* do we have at least one part? If not, ask for the current
       status and return with waiting */
    if (!handlerID->p.oredDevicePending)
    {
        /* during the next call everything up to here should be
               repeated */
        phFuncTaRemoveToMark(handlerID);

        return PHFUNC_ERR_WAITING;
    }

    phFuncTaStop(handlerID);

    /* we have received devices for test. Change the equipment
       specific state now */
    handlerID->p.oredDevicePending = 0;
    for (i=0; i<handlerID->noOfSites; i++)
    {
        if (handlerID->activeSites[i] == 1)
        {
            if (handlerID->p.devicePending[i])
            {
                handlerID->p.devicePending[i] = 0;
                population[i] = PHESTATE_SITE_POPULATED;
            }
            else
                population[i] = PHESTATE_SITE_EMPTY;
        }
        else
        {
            if (handlerID->p.devicePending[i])
            {
                /* something is wrong here, we got a device for an
                           inactive site */
                phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR,
                                 "received device for deactivated site \"%s\"",
                                 handlerID->siteIds[i]);
            }
            population[i] = PHESTATE_SITE_DEACTIVATED;
        }
        handlerID->p.oredDevicePending |= handlerID->p.devicePending[i];
    }   
    phEstateASetSiteInfo(handlerID->myEstate, population, handlerID->noOfSites);

    return retVal;
}
#endif



#ifdef BINDEVICE_IMPLEMENTED
/*****************************************************************************
 *
 * Bin tested device
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *
 * Handler specific implementation of the corresponding plugin function
 * as defined in ph_hfunc.h
 ***************************************************************************/
phFuncError_t privateBinDevice(
                              phFuncId_t handlerID     /* driver plugin ID */,
                              long *perSiteBinMap      /* binning information */
                              )
{
    /*themal alram judement*/
    if( 1 == thermalAlarmFlag ) {
        char response[128] = {0};
        const char* answer = NULL;
        int length = 0;
        char overtempSites[PHCOM_MAX_MESSAGE_LENGTH+1] = "";
        char currentAlarm[PHCOM_MAX_MESSAGE_LENGTH+1] = "";
        char logMsg[256] = {0};

        /*time stamp*/
        struct timeval timeStamp;
        gettimeofday(&timeStamp, NULL);
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "privateBinDevice() called at %d(us), %d(s)", (int)timeStamp.tv_usec, (int)timeStamp.tv_sec);

        /* query current alarm message number */
        if(phComGpibSend(handlerID->myCom, (char*)"CURRENTALM?", strlen("CURRENTALM?"), handlerID->heartbeatTimeout) == PHCOM_ERR_OK)
        {
            if(phComGpibReceive(handlerID->myCom, &answer, &length, handlerID->heartbeatTimeout) == PHCOM_ERR_OK)
            {
                sscanf(answer, "%s", currentAlarm); 
                answer = NULL;
            }
        }

        /* query the overtemp sites */
        if(phComGpibSend(handlerID->myCom, (char*)"OVERTEMP?", strlen("OVERTEMP?"), handlerID->heartbeatTimeout) == PHCOM_ERR_OK)
        {
            if(phComGpibReceive(handlerID->myCom, &answer, &length, handlerID->heartbeatTimeout) == PHCOM_ERR_OK)
            {
                sscanf(answer, "OVERTEMP %s", overtempSites); 
                answer = NULL;
            }
        }
        sprintf(logMsg, "Thermal Alarm occured on the following sites: %s.\nCurrent Alarm message: %s.\nTest program is aborted!\n", overtempSites, currentAlarm);
        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_MESSAGE_1, logMsg);

        /* warning dialog */
        phGuiShowOptionDialog(handlerID->myLogger, PH_GUI_WARN_MESSAGE, logMsg, response);

        /* abort test program */
        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_MESSAGE_0, "Abort flag is set due to Thermal Alarm");
        phTcomSetSystemFlag(handlerID->myTcom, PHTCOM_SF_CI_ABORT, 1);

        /*reset thermal alarm flag*/
        thermalAlarmFlag = 0;
    }

    phFuncError_t retVal = PHFUNC_ERR_OK;

    phEstateSiteUsage_t *oldPopulation;
    int entries;
    phEstateSiteUsage_t population[PHESTATE_MAX_SITES];
    int i;

    /* abort in case of unsuccessful retry */
    if (phFuncTaAskAbort(handlerID))
        return PHFUNC_ERR_ABORTED;

    /* get current site population */
    phEstateAGetSiteInfo(handlerID->myEstate, &oldPopulation, &entries);

    phFuncTaStart(handlerID);
    PhFuncTaCheck(binAndReprobe(handlerID, oldPopulation, NULL, perSiteBinMap));
    phFuncTaStop(handlerID);

    /* modify site population, everything went fine, otherwise we
       would not reach this point */
    for (i=0; i<handlerID->noOfSites; i++)
    {
        if (handlerID->activeSites[i] && 
            (oldPopulation[i] == PHESTATE_SITE_POPULATED ||
             oldPopulation[i] == PHESTATE_SITE_POPDEACT))
        {
            population[i] = 
            oldPopulation[i] == PHESTATE_SITE_POPULATED ?
            PHESTATE_SITE_EMPTY : PHESTATE_SITE_DEACTIVATED;
        }
        else
            population[i] = oldPopulation[i];   
    }

    /* change site population */
    phEstateASetSiteInfo(handlerID->myEstate, population,handlerID->noOfSites);

    return retVal;
}
#endif



#ifdef REPROBE_IMPLEMENTED
/*****************************************************************************
 *
 * reprobe devices
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *
 * Handler specific implementation of the corresponding plugin function
 * as defined in ph_hfunc.h
 ***************************************************************************/
phFuncError_t privateReprobe(
                            phFuncId_t handlerID     /* driver plugin ID */
                            )
{
    phFuncError_t retVal = PHFUNC_ERR_OK;
    long perSiteReprobe[PHESTATE_MAX_SITES];
    long perSiteBinMap[PHESTATE_MAX_SITES];
    int i=0;

    if ( !handlerID->p.reprobeBinDefined )
    {
        /* no reprobe bin number defined */
        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_FATAL,
                         "received reprobe command at site \"%s\" but no reprobe bin number defined \n"
                         "please check the configuration values of \"%s\" and \"%s\"",
                         handlerID->siteIds[i], PHKEY_RP_AMODE, PHKEY_RP_BIN);
        retVal=PHFUNC_ERR_BINNING;
    }
    else
    {
        /* prepare to reprobe everything */
        for (i=0; i<handlerID->noOfSites; i++)
        {
            perSiteReprobe[i] = 1L;
            perSiteBinMap[i] = handlerID->p.reprobeBinNumber;
        }
        retVal=privateBinReprobe(handlerID, perSiteReprobe, perSiteBinMap);
    }

    return retVal;
}
#endif



#ifdef BINREPROBE_IMPLEMENTED
/*****************************************************************************
 *
 * reprobe devices
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *
 * Handler specific implementation of the corresponding plugin function
 * as defined in ph_hfunc.h
 ***************************************************************************/
phFuncError_t privateBinReprobe(
                               phFuncId_t handlerID     /* driver plugin ID */,
                               long *perSiteReprobe     /* TRUE, if a device needs reprobe*/,
                               long *perSiteBinMap      /* valid binning data for each site where
                                                           the above reprobe flag is not set */
                               )
{
    phFuncError_t retVal = PHFUNC_ERR_OK;

    phEstateSiteUsage_t *oldPopulation;
    int entries;
    phEstateSiteUsage_t population[PHESTATE_MAX_SITES];
    int i;

    /* abort in case of unsuccessful retry */
    if (phFuncTaAskAbort(handlerID))
        return PHFUNC_ERR_ABORTED;

    /* remember which devices we expect now */
    for (i=0; i<handlerID->noOfSites; i++)
        handlerID->p.deviceExpected[i] =
        (handlerID->activeSites[i] && perSiteReprobe[i]);

    /* get current site population */
    phEstateAGetSiteInfo(handlerID->myEstate, &oldPopulation, &entries);

    phFuncTaStart(handlerID);

    PhFuncTaCheck(binAndReprobe(handlerID, oldPopulation,
                                perSiteReprobe, perSiteBinMap));

    /* wait for reprobed parts */
    phFuncTaMarkStep(handlerID);
    PhFuncTaCheck(waitForParts(handlerID));

    /* do we have at least one part? If not, ask for the current
       status and return with waiting */
    if (!handlerID->p.oredDevicePending)
    {
        /* during the next call everything up to here should be
           repeated */
        phFuncTaRemoveToMark(handlerID);

        return PHFUNC_ERR_WAITING;
    }

    phFuncTaStop(handlerID);
    phEstateASetPauseInfo(handlerID->myEstate, 0);

    /* we have received devices for test after a reprobe.
       Change the equipment specific state now but do not present any
       devices that were not existent before this reprobe action */
    handlerID->p.oredDevicePending = 0;
    for (i=0; i<handlerID->noOfSites; i++)
    {
        if (handlerID->activeSites[i] == 1)
        {
            if (perSiteReprobe[i])
            {
                if (handlerID->p.devicePending[i])
                {
                    if (oldPopulation[i] == PHESTATE_SITE_POPULATED ||
                        oldPopulation[i] == PHESTATE_SITE_POPDEACT)
                        handlerID->p.devicePending[i] = 0;
                    else
                        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_WARNING,
                                         "new device at site \"%s\" will not be tested during reprobe action (delayed)",
                                         handlerID->siteIds[i]);
                    population[i] = oldPopulation[i];
                }
                else
                {
                    if (oldPopulation[i] == PHESTATE_SITE_POPULATED ||
                        oldPopulation[i] == PHESTATE_SITE_POPDEACT)
                    {
                        /* something is wrong here, we expected a reprobed
                           device */
                        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR,
                                         "did not receive device that was scheduled for reprobe at site \"%s\"",
                                         handlerID->siteIds[i]);
                        population[i] = PHESTATE_SITE_EMPTY;
                    }
                    else
                        population[i] = oldPopulation[i];
                }
            }
            else /* ! perSiteReprobe[i] */
            {
                /*
                 * all devices need to receive a bin or reprobe data,
                 * and devices that were not reprobed must be gone
                 */
                if (handlerID->p.devicePending[i])
                {
                    /* ignore any new devices */
                    phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_WARNING,
                                     "new device at site \"%s\" will not be tested during reprobe action (delayed)",
                                     handlerID->siteIds[i]);
                }
                population[i] = PHESTATE_SITE_EMPTY;
                if (oldPopulation[i] == PHESTATE_SITE_POPDEACT ||
                    oldPopulation[i] == PHESTATE_SITE_DEACTIVATED)
                    population[i] = PHESTATE_SITE_DEACTIVATED;
            }
        }
        else
        {
            if (handlerID->p.devicePending[i])
            {
                /* something is wrong here, we got a device for an
                   inactive site */
                phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR,
                                 "received device for deactivated site \"%s\"",
                                 handlerID->siteIds[i]);
            }
            population[i] = PHESTATE_SITE_DEACTIVATED;
        }
        handlerID->p.oredDevicePending |= handlerID->p.devicePending[i];
    }
    phEstateASetSiteInfo(handlerID->myEstate, population,handlerID->noOfSites);

    return retVal;
}
#endif


/* perform pause the handler operation */
static phFuncError_t doPauseHandler(phFuncId_t handlerID)
{
    static char handlerAnswer[512] = "";

    phFuncTaMarkStep(handlerID);

    if (!handlerID->p.paused)
    {
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "Sending pause command to handler...");
        switch (handlerID->model)
        {
        case PHFUNC_MOD_GS1:
        case PHFUNC_MOD_M45:
        case PHFUNC_MOD_M48:
        case PHFUNC_MOD_DLT: /*DLT enhance */
        /*Begin, Adam Huang, 29 JAN 2015*/
        case PHFUNC_MOD_YUSHAN: /* YUSHAN enhance*/
        /*End*/
            PhFuncTaCheck(phFuncTaSend(handlerID, "TESTPEND 0%s", handlerID->p.eol));
            PhFuncTaCheck(phFuncTaReceive(handlerID, 1, "%511[^\n\r]", handlerAnswer));
            setStrUpper(handlerAnswer);
            break;
        default:
            break;
        }

        if (strcmp(handlerAnswer, "SETTINGOK") == 0)
        {
            handlerID->p.paused = 1;
            phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "Handler is paused...");
        }
        else
        {
            phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_WARNING, "Failed to pause the handler...");
            PhFuncTaCheck(queryStatus(handlerID, 0));
            phFuncTaRemoveToMark(handlerID);
            return PHFUNC_ERR_WAITING;
        }
    }

    return PHFUNC_ERR_OK;
}

/* perform unpause the handler operation */
static phFuncError_t doUnpauseHandler(phFuncId_t handlerID)
{
    static char handlerAnswer[512] = "";

    phFuncTaMarkStep(handlerID);

    if (handlerID->p.paused)
    {
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "Sending continue command to handler...");
        switch (handlerID->model)
        {
        case PHFUNC_MOD_GS1:
        case PHFUNC_MOD_M45:
        case PHFUNC_MOD_M48:
        case PHFUNC_MOD_DLT: /*DLT enhance*/
        /*Begin, Adam Huang, 29 JAN 2015*/
        case PHFUNC_MOD_YUSHAN: /* YUSHAN enhance*/
        /*End*/
            PhFuncTaCheck(phFuncTaSend(handlerID, "TESTPEND 1%s", handlerID->p.eol));
            PhFuncTaCheck(phFuncTaReceive(handlerID, 1, "%511[^\n\r]", handlerAnswer));
            setStrUpper(handlerAnswer);
            break;
        default:
            break;
        }

        if (strcmp(handlerAnswer, "SETTINGOK") == 0)
        {
            handlerID->p.paused = 0;
            phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "Handler continues...");
        }
        else
        {
            phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_WARNING, "Failed to continue the handler...");
            PhFuncTaCheck(queryStatus(handlerID, 0));
            phFuncTaRemoveToMark(handlerID);
            return PHFUNC_ERR_WAITING;
        }
    }

    return PHFUNC_ERR_OK;
}



#ifdef PAUSE_IMPLEMENTED
/*****************************************************************************
 *
 * Notify SmarTest pause to handler plugin
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *
 * Handler specific implementation of the corresponding plugin function
 * as defined in ph_hfunc.h
 ***************************************************************************/
phFuncError_t privateSTPaused(
                             phFuncId_t handlerID     /* driver plugin ID */
                             )
{
    int isPaused;

    if (phFuncTaAskAbort(handlerID))
    {
        return PHFUNC_ERR_ABORTED;
    }

    if (handlerID->p.pauseHandler)
    {
        phEstateAGetPauseInfo(handlerID->myEstate, &isPaused);

        if (!isPaused)
        {
            phFuncTaStart(handlerID);
            PhFuncTaCheck(doPauseHandler(handlerID));
            phFuncTaStop(handlerID);
        }

        if (handlerID->p.paused)
        {
            phEstateASetPauseInfo(handlerID->myEstate, 1);
        }
    }
    return PHFUNC_ERR_OK;
}
#endif



#ifdef UNPAUSE_IMPLEMENTED
/*****************************************************************************
 *
 * Notify SmarTest un-pause to handler plugin
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *
 * Handler specific implementation of the corresponding plugin function
 * as defined in ph_hfunc.h
 ***************************************************************************/
phFuncError_t privateSTUnpaused(
                               phFuncId_t handlerID     /* driver plugin ID */
                               )
{
    int isPaused;

    if (phFuncTaAskAbort(handlerID))
    {
        return PHFUNC_ERR_ABORTED;
    }

    phEstateAGetPauseInfo(handlerID->myEstate, &isPaused);

    if (isPaused)
    {
        phFuncTaStart(handlerID);
        PhFuncTaCheck(doUnpauseHandler(handlerID));
        phFuncTaStop(handlerID);
    }

    if (!handlerID->p.paused)
    {
        phEstateASetPauseInfo(handlerID->myEstate, 0);
    }

    return PHFUNC_ERR_OK;
}
#endif



#ifdef DIAG_IMPLEMENTED
/*****************************************************************************
 *
 * retrieve diagnostic information
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *
 * Handler specific implementation of the corresponding plugin function
 * as defined in ph_hfunc.h
 ***************************************************************************/
phFuncError_t privateDiag(
                         phFuncId_t handlerID     /* driver plugin ID */,
                         char **diag              /* pointer to handlers diagnostic output */
                         )
{
    *diag = phLogGetLastErrorMessage();
    return PHFUNC_ERR_OK;
}
#endif



#ifdef STATUS_IMPLEMENTED
/*****************************************************************************
 *
 * Current status of plugin
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *
 * Handler specific implementation of the corresponding plugin function
 * as defined in ph_hfunc.h
 ***************************************************************************/
phFuncError_t privateStatus(
                           phFuncId_t handlerID                /* driver plugin ID */,
                           phFuncStatRequest_t action          /* the current status action
                                                                  to perform */,
                           phFuncAvailability_t *lastCall      /* the last call to the
                                                                  plugin, not counting calls
                                                                  to this function */
                           )
{
    phFuncError_t retVal = PHFUNC_ERR_OK;

    return retVal;
}
#endif



#ifdef UPDATE_IMPLEMENTED
/*****************************************************************************
 *
 * update the equipment state
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *
 * Handler specific implementation of the corresponding plugin function
 * as defined in ph_hfunc.h
 ***************************************************************************/
phFuncError_t privateUpdateState(
                                phFuncId_t handlerID     /* driver plugin ID */
                                )
{
    /* by default not implemented */
    ReturnNotYetImplemented("privateUpdateState");
}
#endif



#ifdef COMMTEST_IMPLEMENTED
/*****************************************************************************
 *
 * Communication test
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *
 * Prober specific implementation of the corresponding plugin function
 * as defined in ph_hfunc.h
 ***************************************************************************/
phFuncError_t privateCommTest(
                             phFuncId_t handlerID     /* driver plugin ID */,
                             int *testPassed          /* whether the communication test has passed
                                                         or failed        */
                             )
{

    phFuncError_t retVal = PHFUNC_ERR_OK;
    char *handlerRunning = NULL; //init

    if (phFuncTaAskAbort(handlerID))
        return PHFUNC_ERR_ABORTED;

    phFuncTaStart(handlerID);

    retVal = checkHandlerRunning(handlerID, &handlerRunning);


    phLogFuncMessage(handlerID->myLogger, LOG_DEBUG,
                     "FR? handler running returns \"%s\" ",
                     handlerRunning);

    phFuncTaStop(handlerID);

    /* return result, there is no real check for the model here (so far) */
    if (testPassed)
        *testPassed = (retVal == PHFUNC_ERR_OK) ? 1 : 0;
    return retVal;
}
#endif



#ifdef DESTROY_IMPLEMENTED
/*****************************************************************************
 *
 * destroy the driver
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *
 * Handler specific implementation of the corresponding plugin function
 * as defined in ph_hfunc.h
 ***************************************************************************/
phFuncError_t privateDestroy(
                            phFuncId_t handlerID     /* driver plugin ID */
                            )
{
    /* by default not implemented */
    ReturnNotYetImplemented("privateDestroy");
}
#endif


/*****************************************************************************
 *
 * for a certain GetStatus query, get the corresponding GPIB command
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *    all the actual GPIB commands are stored locally, this function retrieves the 
 *    command corresponding to the "token".      
 *
 * Return:
 *    function return SUCCEED if everything is OK, FAIL if error; and the found 
 *    GPIB command will be returned with the parameter "pGpibCommand"
 *
 ***************************************************************************/
static int getGpibCommandForGetStatusQuery(
                                          phFuncId_t handlerID,
                                          char **pGpibCommand, 
                                          const char *token,
                                          const char *param
                                          )
{
    /* these static array must be ordered by the first field */
    static const  phStringPair_t sGpibCommands[] = 
    {
        /*Begin CR92686, Adam Huang, 31 Jan 2015*/
        {PHKEY_NAME_HANDLER_STATUS_GET_ACM_CONTACT, "ACMCONTACT?"},
        {PHKEY_NAME_HANDLER_STATUS_GET_ACM_ERROR,"ACMERROR?"},
        {PHKEY_NAME_HANDLER_STATUS_GET_ACM_JAM,"ACMJAM?"},
        {PHKEY_NAME_HANDLER_STATUS_GET_ACM_RETRY,"ACMRETRY?"},
        {PHKEY_NAME_HANDLER_STATUS_GET_ACM_TIME,"ACMTIME?"},
        {PHKEY_NAME_HANDLER_STATUS_GET_ACM_TOTAL,"ACMTOTAL?"},
        {PHKEY_NAME_HANDLER_STATUS_GET_CURRENT_ALM,"CURRENTALM?"},
        {PHKEY_NAME_HANDLER_STATUS_GET_DEVICEID,"CCD"},        /*GS1 enhance*/
        {PHKEY_NAME_HANDLER_STATUS_GET_DVID,"DVID?"},          /*YUSHAN enhance*/
        {PHKEY_NAME_HANDLER_STATUS_GET_HANDLER_NUMBER,"HANDLERNUM?"},
        {PHKEY_NAME_HANDLER_STATUS_GET_LDPOCKET,"LDPOCKET?"},  /*DLT enhance */
        {PHKEY_NAME_HANDLER_STATUS_GET_LDTRAY,"LDTRAY?"},      /*DLT enhance */
        {PHKEY_NAME_HANDLER_STATUS_GET_LOT_ERROR,"LOTERROR?"},
        {PHKEY_NAME_HANDLER_STATUS_GET_LOT_JAM,"LOTJAM?"},
        {PHKEY_NAME_HANDLER_STATUS_GET_LOT_RETRY,"LOTRETRY?"},
        {PHKEY_NAME_HANDLER_STATUS_GET_LOT_TIME,"LOTTIME?"},
        {PHKEY_NAME_HANDLER_STATUS_GET_LOT_TOTAL,"LOTTOTAL?"},
        {PHKEY_NAME_HANDLER_STATUS_GET_MEASTEMP,"MEASTEMP?"},
        {PHKEY_NAME_HANDLER_STATUS_GET_SETTEMP,"SETTEMP?"},
        {PHKEY_NAME_HANDLER_STATUS_GET_TLOOP,"TLOOP?"},         /*YUSHAN enhance*/
        {PHKEY_NAME_HANDLER_STATUS_GET_TSSET,"TSSET?"},         /*YUSHAN enhance*/
        /*End*/

    };
    static char buffer[MAX_STATUS_MSG] = "";
    int retVal = SUCCEED;
    const phStringPair_t *pStrPair = NULL;
    int paramSpecified = NO;
    int ignoreParam = NO;

    if (strlen(param) > 0)
    {
        paramSpecified = YES;
        if (strcasecmp(token, PHKEY_NAME_HANDLER_STATUS_GET_DEVICEID) != 0)
        {
            phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR, 
                    "the status query does not require any parameters!\n"
                    "Ignore the parameter %s.", 
                    param);
            ignoreParam = YES;
            retVal = SUCCEED;
        }
    }

    if (retVal == SUCCEED)
    {
        pStrPair = phBinSearchStrValueByStrKey(sGpibCommands, LENGTH_OF_ARRAY(sGpibCommands), token);
    }

    if (pStrPair != NULL)
    {
        strcpy(buffer,"");
        if (paramSpecified == YES && ignoreParam == NO)
        {
            /* add a space character between command and parameter */
            sprintf(buffer, "%s ", pStrPair->value);
            strcat(buffer, param);
        }
        else
        {
            sprintf(buffer, "%s", pStrPair->value);
        }
        *pGpibCommand = buffer;
    }
    else
    {
        retVal = FAIL;
    }

    return retVal;
}


#ifdef GETSTATUS_IMPLEMENTED
/*****************************************************************************
 *
 * The stub function for get status
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *  use this function to retrieve the information/parameter 
 *  from handler.
 *
 ***************************************************************************/
phFuncError_t privateGetStatus(
                              phFuncId_t handlerID,       /* driver plugin ID */
                              const char *commandString,  /* the string of command, i.e. the key to
                                                             get the information from Handler */
                              const char *paramString,    /* the parameter for command string */
                              char **responseString       /* output of the response string */
                              )
{
    static char response[MAX_STATUS_MSG] = "";
    phFuncError_t retVal = PHFUNC_ERR_OK;
    const char *token = commandString;
    const char *param = paramString;
    char *gpibCommand = NULL;
    int found = FAIL;
    response[0] = '\0';
    *responseString = response;

    if ( phFuncTaAskAbort(handlerID) )
    {
        return PHFUNC_ERR_ABORTED;
    }

    phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_TRACE,
                     "privateGetStatus, token = ->%s<-, param = ->%s<-", token, param);

    /* fix CR-135466 to unify get barcode command */
    if(strcasecmp(token, PHKEY_NAME_HANDLER_STATUS_GET_DEVICEID) == 0 \
        || strcasecmp(token, PHKEY_NAME_HANDLER_STATUS_GET_BARCODE) == 0 \
        || strcasecmp(token, PHKEY_NAME_HANDLER_STATUS_GET_DVID) == 0)
    {
      if (PHFUNC_MOD_GS1 == handlerID->model)
      {
          token = PHKEY_NAME_HANDLER_STATUS_GET_DEVICEID;
      }
      else if (PHFUNC_MOD_YUSHAN == handlerID->model)
      {
          token = PHKEY_NAME_HANDLER_STATUS_GET_DVID;
      }
    }

    phLogFuncMessage(handlerID->myLogger, LOG_DEBUG,
                     "unify command, token = ->%s<-, param = ->%s<-", token, param);

    found = getGpibCommandForGetStatusQuery(handlerID, &gpibCommand, token, param);

    phFuncTaStart(handlerID);

    if ( found == SUCCEED )
    {
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "privateGetStatus, gpibCommand = ->%s<-", gpibCommand);

        if(PHFUNC_MOD_GS1 == handlerID->model && strcasecmp(token, PHKEY_NAME_HANDLER_STATUS_GET_DEVICEID) == 0)
        {
            /* 2D bar code enhancement of GS1 */

            /* trancate the data of static string */
            memset(response, 0, MAX_STATUS_MSG);

            static char szDeviceIDRet[PHESTATE_MAX_SITES*30] = {0};

            /* use configured number of sites to decide how many times we need to send ccd command*/
            int iDivision = handlerID->noOfSites%8 ? handlerID->noOfSites/8+1 : handlerID->noOfSites/8;

            if( 1 == deviceIDReloadFlag )
            {
                /* trancate the data of static string */
                memset(szDeviceIDRet, 0, PHESTATE_MAX_SITES*30);

                /* get all 2d bar codes of all DUTs when the reload flag is set*/
                int itemp = 0;
                for(itemp=0; itemp<iDivision; itemp++)
                {
                    char szTempRes[MAX_STATUS_MSG] = {0};    /* temp string to receive the response */
                    PhFuncTaCheck(phFuncTaSend(handlerID, "CCD %d?%s", itemp+1, handlerID->p.eol));
                    localDelay_us(100000);
                    PhFuncTaCheck(phFuncTaReceive(handlerID, 1, "%4095[^\r\n]", szTempRes));
                    //skip "CCD " to get 2D bar code for all DUTs
                    strcat(szDeviceIDRet, szTempRes+4);
                }

                /*unset device ID reload flag*/
                deviceIDReloadFlag = 0;
            }

            if (0 == strlen(param))
            {
                /* for the command "ccd" without parameter, we will directly return all 2D bar codes of DUTs */
                /* the format of response is 1,xxxxxxxxxxxxxxxx;2,xxxxxxxxxxxxxxxx;......n,xxxxxxxxxxxxxxxx; n is number of DUTs*/
                //strncpy(response, szDeviceIDRet, PHESTATE_MAX_SITES*30-1);
                strncpy(response, szDeviceIDRet, MAX_STATUS_MSG-1);
                response[MAX_STATUS_MSG-1] = '\0';
            }
            else
            {
                int iDeviceID = atoi(param);
                /* try to find the 2D bar code of specific Device ID */
                char strSubStr[MAX_STATUS_MSG] = {0};
                sprintf(strSubStr, "%d,", iDeviceID);
                char *pStrPosition = strstr(szDeviceIDRet, strSubStr);

                if(NULL == pStrPosition || 0 == iDeviceID)
                {
                    phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "The specific Deivce ID is Invalid, will return \"DATANG\"!");
                    strcpy(response, "DATANG");
                }
                else
                {
                    /* strcspn() to get the number of char between "n," to ";", covers "DATANG" or 16 characters of 2D bar codes */
                    int iskip = strlen(strSubStr);
                    int inum = strcspn(pStrPosition+iskip, ";");
                    strncpy(response, pStrPosition+iskip, inum);
                }
            }
        }
        else
        {
            PhFuncTaCheck(phFuncTaSend(handlerID, "%s%s", gpibCommand, handlerID->p.eol));
            localDelay_us(100000);
            PhFuncTaCheck(phFuncTaReceive(handlerID, 1, "%4095[^\r\n]", response));
        }

        if(handlerID->model == PHFUNC_MOD_YUSHAN)
        {
            char szTemp[MAX_STATUS_MSG] = {0};
            if(strncmp(response , "DVID", strlen("DVID")) == 0 ) {
                sscanf(response, "DVID %s", szTemp);
                strncpy(response, szTemp, strlen(szTemp)+1);
            }
            else if(strncmp(response , "TLOOP", strlen("TLOOP")) == 0 ) {
                sscanf(response, "TLOOP %s", szTemp);
                strncpy(response, szTemp, strlen(szTemp)+1);
            }
            else if(strncmp(response , "TSSET", strlen("TSSET")) == 0 ) {
                sscanf(response, "TSSET %s", szTemp);
                strncpy(response, szTemp, strlen(szTemp)+1);
            }
        }
    }
    else
    {
        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_WARNING,
                         "The key \"%s\" is not available, or may not be supported yet", token);
        sprintf(response, "%s_KEY_NOT_AVAILABLE", token);
    }


    /* ensure null terminated */
    response[strlen(response)] = '\0';

    phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_TRACE,
                     "privateGetStatus, answer ->%s<-, length = %d",
                     response, strlen(response));

    phFuncTaStop(handlerID);
    return retVal;
}
#endif



/*****************************************************************************
 *
 * for a certain SetStatus, get the corresponding GPIB command
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *    all the actual GPIB commands are stored locally, this function retrieves the 
 *    command corresponding to the "token".   
 *
 * Return:
 *    function return SUCCEED if everything is OK, FAIL if error; and the found 
 *    GPIB command will be returned with the parameter "pGpibCommand"
 *
 ***************************************************************************/
static int getGpibCommandForSetStatusQuery(
                                          phFuncId_t handlerID,
                                          char **pGpibCommand, 
                                          const char *token,
                                          const char *param
                                          )
{
    /* these static array must be ordered by the first field */
    static const  phStringPair_t sGpibCommands[] = 
    {
        {PHKEY_NAME_HANDLER_STATUS_SET_ACM_CLEAR,"ACMCLEAR?"},
        {PHKEY_NAME_HANDLER_STATUS_SET_ACM_RETEST_CLEAR,"ACMRETESTCLEAR?"},
        {PHKEY_NAME_HANDLER_STATUS_SET_CHANGE_PAGE,"CHANGEPAGE"},
        {PHKEY_NAME_HANDLER_STATUS_SET_GPIB_TIMEOUT,"GPIBTIMEOUT"},
        {PHKEY_NAME_HANDLER_STATUS_SET_INPUT_QTY,"INPUTQTY"},
        {PHKEY_NAME_HANDLER_STATUS_SET_LOTCLEAR,"LOTCLEAR?"},
        {PHKEY_NAME_HANDLER_STATUS_SET_LOT_END,"LOTEND"},
        {PHKEY_NAME_HANDLER_STATUS_SET_LOT_RETEST_CLEAR,"LOTRETESTCLEAR?"},
        {PHKEY_NAME_HANDLER_STATUS_SET_PROFILE, "PROFILE" },
        {PHKEY_NAME_HANDLER_STATUS_SET_SITE_PROFILE, "SITEPROFILE:" },
        {PHKEY_NAME_HANDLER_STATUS_SET_SOFT_RESET,"SOFTRESET"},
        {PHKEY_NAME_HANDLER_STATUS_SET_SOUND_OFF,"SOUNDOFF"},
        {PHKEY_NAME_HANDLER_STATUS_SET_START, "START"},
        {PHKEY_NAME_HANDLER_STATUS_SET_STOP,"STOP"},
    };
    static char buffer[MAX_STATUS_MSG] = "";
    int retVal = SUCCEED;
    const phStringPair_t *pStrPair = NULL;
    int paramSpecified = NO;
    int ignoreParam = NO;

    if (strlen(param) > 0 )
    {
        paramSpecified = YES;
        if (strcasecmp(token, PHKEY_NAME_HANDLER_STATUS_SET_CHANGE_PAGE) != 0 && 
            strcasecmp(token, PHKEY_NAME_HANDLER_STATUS_SET_GPIB_TIMEOUT) != 0 &&
            strcasecmp(token, PHKEY_NAME_HANDLER_STATUS_SET_PROFILE) != 0 &&
            strcasecmp(token, PHKEY_NAME_HANDLER_STATUS_SET_SITE_PROFILE) != 0 &&
            strcasecmp(token, PHKEY_NAME_HANDLER_STATUS_SET_LOT_END) != 0 &&
            strcasecmp(token, PHKEY_NAME_HANDLER_STATUS_SET_INPUT_QTY) != 0 ) 
        {
            phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR, 
                            "the status setting does not require any parameters!\n"
                            "Ignore the parameter %s.", 
                            param);
            ignoreParam = YES;
            retVal = SUCCEED;
        }
    }

    if (retVal == SUCCEED)
    {
        pStrPair = phBinSearchStrValueByStrKey(sGpibCommands, LENGTH_OF_ARRAY(sGpibCommands), token);
    }

    if (pStrPair != NULL)
    {
        strcpy(buffer,"");
        if (paramSpecified == YES && ignoreParam == NO)
        {
            /* add a space character between command and parameter */
            sprintf(buffer, "%s ", pStrPair->value);
            strcat(buffer, param);
        }
        else
        {
            sprintf(buffer, "%s", pStrPair->value);
        }
        *pGpibCommand = buffer;
    }
    else
    {
        retVal = FAIL;
    }

    return retVal;
}


#ifdef SETSTATUS_IMPLEMENTED
/*****************************************************************************
 *
 * The stub function for set status
 *
 * Authors: Xiaofei Han
 *
 * Description:
 *  use this function to set status control command to the handler.
 *
 ***************************************************************************/
phFuncError_t privateSetStatus(
                              phFuncId_t handlerID,       /* driver plugin ID */
                              const char *token,          /* the string of command, i.e. the key to
                                                             get the information from Handler */
                              const char *param           /* the parameter for command string */
                              )
{
    static char response[MAX_STATUS_MSG] = "";
    phFuncError_t retVal = PHFUNC_ERR_OK;
    char *gpibCommand = NULL;
    int found = FAIL;

    if ( phFuncTaAskAbort(handlerID) )
    {
        return PHFUNC_ERR_ABORTED;
    }

    phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_TRACE,
                     "privateSetStatus, token = ->%s<-, param = ->%s<-", token, param);

    found = getGpibCommandForSetStatusQuery(handlerID, &gpibCommand, token, param);
    if ( found == SUCCEED )
    {
        phLogFuncMessage(handlerID->myLogger, LOG_DEBUG,
                         "privateSetStatus, gpibCommand = ->%s<-", gpibCommand);
        PhFuncTaCheck(phFuncTaSend(handlerID, "%s%s", gpibCommand, handlerID->p.eol));
        localDelay_us(100000);
        retVal = phFuncTaReceive(handlerID, 1, "%4095[^\r\n]", response);
        if (retVal != PHFUNC_ERR_OK)
        {
            phFuncTaRemoveStep(handlerID); 
            return retVal;
        }
    }
    else
    {
        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_WARNING,
                         "The key \"%s\" is not available, or may not be supported yet", token);
        sprintf(response, "%s_KEY_NOT_AVAILABLE", token);
    }


    /* ensure null terminated */
    response[strlen(response)] = '\0';

    if(strcmp(response, "SETTINGNG") == 0)
    {
        /* command is not executd successfully */
        phLogFuncMessage(handlerID->myLogger, PHLOG_TYPE_ERROR,
                         "Handler replied \"%s\" ", response);
        retVal = PHFUNC_ERR_ANSWER;
        PhFuncTaCheck(queryStatus(handlerID, 0));
    }

    phFuncTaStop(handlerID);

    return retVal;
}
#endif

#ifdef LOTSTART_IMPLEMENTED
/*****************************************************************************
 *
 * Wait for lot start signal from handler
 *
 * Authors: Adam Huang
 *
 * Description:
 *
 ***************************************************************************/
phFuncError_t privateLotStart(
                              phFuncId_t handlerID,      /* driver plugin ID */
                              int timeoutFlag
                              )
{
    phFuncError_t retVal = PHFUNC_ERR_OK;

    phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "Entering privateLotStart, timeoutFlag = %s", timeoutFlag ? "TRUE" : "FALSE");

    /* abort in case of unsuccessful retry */
    if ( phFuncTaAskAbort(handlerID) )
    {
        return PHFUNC_ERR_ABORTED;
    }

    phFuncTaStart(handlerID);

    phFuncTaMarkStep(handlerID);

    /*****************************************************************************
     * for lot start signal, it will call pollParts() in waitForParts(), and if FULLSITES correctly return, then oredDevicePending will be set
     * after lot start, the application model file will call ph_device_start(), it will check oredDevicePending
     * if the oredDevicePending has been set, the test will directly start without calling waitForParts()
     ***************************************************************************/
    PhFuncTaCheck(waitForParts(handlerID));

    if (0 == handlerID->p.lotStarted)
    {
        /* repeats until receive srq 0x43 or 0x06 */
        phFuncTaRemoveToMark(handlerID);

        return PHFUNC_ERR_WAITING;
    }

    phFuncTaStop(handlerID);

    phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "Exiting privateLotStart, retVal = %d", retVal);
    return retVal;
}
#endif

#ifdef LOTDONE_IMPLEMENTED
/*****************************************************************************
 *
 * Wait for lot end signal from handler
 *
 * Authors: Adam Huang
 *
 * Description:
 *
 ***************************************************************************/
phFuncError_t privateLotDone(
                              phFuncId_t handlerID,      /* driver plugin ID */
                              int timeoutFlag
                              )
{
  phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "Entering privateLotDone");
  phFuncError_t retVal = PHFUNC_ERR_OK;
  if (1 == finalLotEndFlag)
  {
      /* exit the lot level if final lot end flag has been set */
      phTcomSetSystemFlag(handlerID->myTcom, PHTCOM_SF_CI_LEVEL_END, 1L);
      finalLotEndFlag = 0;
  }
  phLogFuncMessage(handlerID->myLogger, LOG_DEBUG, "Exiting privateLotDone, retVal = %d", retVal);
  return retVal;
}
#endif
 

/*****************************************************************************
 * End of file
 *****************************************************************************/
