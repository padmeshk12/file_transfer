# -----------------------------------------------------------------------------
#      This is a handler specific configuration file for handler drivers
#         (c) Copyright Advantest 2015
# -----------------------------------------------------------------------------
# The general syntax of this file is:
#
#       file           = definitionlist
#
#       definitionlist = definition [definitionlist]
#
#       definition     = [hint] key [flags] data
#
#       key            = string ':'
#
#       data           = array | simple_data
#
#       simple_data    = number | quoted_string
#
#       quoted_string  = '"' string '"' | ''' string '''
#
#       array          = '[' datalist ']'
#
#       datalist       =  data [datalist]
#
#       hint           = '{' string '}'
#
#       flags          = '<' characterlist '>'
#
#       characterlist  = character [characterlist]
#
#       string         = alphanumeric string
#
#       number         = any floating point number
#
#       character      = 'F'
#
# Everything following a '#' character up to the end of the line, is 
# treated as a comment. A '#' within a string is handled correctly
# as part of the string.
#
# A <hint> group (several continuous lines) immediately preceding a 
# <definition> is used as a hint for this definition and may occur 
# in a user interface to give some advise for possible changes.
#
#           For a detailed description please refer to the document
#                     "Prober/Handler Drivers"
# -----------------------------------------------------------------------------



# Parameters for Equipment Identification -------------------------------------


# The name of the specific handler model within the handler family, as
# accepted by the plug-in

{ The name of the handler family. Must be defined, no default }

handler_family: < F >                   "unknown"

# The name of the specific handler model within the handler family, as
# accepted by the plug-in

{ The name of the handler model. Must be defined, no default }

model: < F >                            "unknown"


# Parameters for Log File Generation ------------------------------------------


# In addition to printing messages to the Report Window, the driver
# can also write these messages to a file.  If the following value is
# not an empty string, it is treated as a log file for driver
# messages. Environment variable substitution in the path definition
# works.

{ The location of the drivers message log file, default: "" }

driver_message_log:                     "/opt/hp93000/testcell/phcontrol/log/messages"

# For debugging purposes, the driver may generate more or less verbose
# messages. The level of verbosity is defined by this parameter.

{ The debug level of the driver, -1 to 4, or 9, default 1 }

debug_level:                            0

# In addition to printing warnings and errors to the Report Window,
# the driver can also write these to a file. Also `trace' information
# will be written to this file. If the following value is not an empty
# string, it is treated as an additional log file for errors and
# warnings. Environment variable substitution in the path definition
# works.

{ The location of the drivers error log file, default: "" }

driver_error_log:                       "/opt/hp93000/testcell/phcontrol/log/errors"

# The messages and warnings/errors log files generated by the driver
# may be kept or overwritten with each start-up of the driver (each
# testprogram run), or with each change of one of the parameters
# driver_message_log or driver_error_log. This parameter sets the
# number of old log files to be kept by renaming the files following
# the scheme:
#
# file -> file_old_1 -> file_old_2 -> file_old_3 -> ...
# -> file_old_<log_files_to_keep>

{ How many old log files with similar names to keep, default: 0 }

log_files_to_keep:                      0

# At start-up, the driver may log its configuration to the message log
# output. If set to "yes", the configuration will be logged at the
# ph_driver_start call from the test cell client.

{ Log configuration to the message log file, "yes" or "no", default: "no" }

log_configuration: < F >                "yes"

# If set to "yes", the driver will add internal function calls
# together with the passed parameters to the warnings/error
# output. This should be used for debugging only.

{ Trace driver internal function calls, "yes" or "no, default: "no" }

trace_driver_calls:                     "no"


# Parameters for Driver Mode --------------------------------------------------


# For demonstrations, debug scenarios, and problem analysis, the
# driver may work in "off-line" mode rather then in "on-line"
# mode. During off-line mode, no communication with the equipment
# takes place. Instead, the equipment's behavior is simulated to the
# driver (error-free operation is simulated).

{ Interface communication mode, "on-line" or "off-line", default: "on-line" }

communication_mode: < F >               "on-line"

# Sometimes it is necessary for the operator to remove the handler
# from the tester and to do the device handling by hand. This may even
# be necessary during driver run-time. This parameter allows you to
# set the driver to the hand test mode. When running in this mode, the
# operator is prompted every time, a device handling action needs to
# be performed. Also, no driver communication to the handler takes
# place.

{ Activate hand test mode, "on" or "off", default: "off" }

hand_test_mode:                         "off"

# Sometimes it is necessary to slow down all driver operations, for
# example when testing a new test cell client, or when analyzing a
# malfunction. This parameter sets the driver to the single step
# mode. In single step mode the operator is prompted for confirmation
# at each call from the test cell client to the handler driver.

{ Activate singel step mode, "on" or "off", default: "off" }

single_step_mode:                       "off"


# Parameters for Operator interventions ---------------------------------------


# At driver startup, the operator may be asked to confirm the current
# configuration. If the operator confirms the configuration, handling
# operation will start. Otherwise, the testprogram will be
# aborted. The driver will only ask for configuration confirmation, if
# also the parameter log_configuration is set to "yes". This prints
# the current configuration file to the report window, and this way
# allows the operator to check the configuration before confirming it.

{ Ask for confirmation of the configuration at driver startup, default: "no" }

ask_for_configuration_confirmation: < F > "no"

# If a timeout occurs while the driver waits for the next part to be
# tested (next device from the handler, or next die on the wafer), the
# driver can ask the operator to take action ("operator-help"), or can
# continue waiting for parts ("continue"). In the latter case, the
# driver will stop waiting only if a new part is delivered by the
# handler or prober (and the delivery is recognized).
#
# Note: a new action "skip" is added for the Multi-Equipment-Control(MEC) 
# driver. "skip" means whenever timeout occurs, the driver will stop waiting 
# for the parts and the driver function will return with success. If MEC 
# driver is not used, the "skip" action should not be used.


{ What should happen, if a timeout occurs while waiting for parts,
  default: "continue" }

waiting_for_parts_timeout_action:       "operator-help"

# The time in seconds which the driver will wait for a new part (for
# handlers: the next device; for probers: the next die) from the
# equipment. If this time is exceeded (timeout), a message will be
# generated by the driver, and the action defined by the parameter
# waiting_for_parts_timeout_action will be taken.

{ Timeout in [seconds] to insert devices, default: 30 }

waiting_for_parts_timeout:              30


# User Defined Dialog Box -----------------------------------------------------

# At certain key moments during the operation of the driver a configurable
# dialog box can be set to appear. The idea being that the operator may be
# prompted to perform some action to ensure the smooth operation of the
# prober/handler and the driver. For each user defined dialog box the
# following parameters may be defined:
#
# dialog_specific_key: [ "title" "message" "diag-format" "diag-freq" ]
#
# where:
#
# dialog_specific_key   is the configuration key value as defined below.
#                       For example, to make a user defined dialog box
#                       appear before any commmunication is sent to the
#                       prober/handler the "dialog_communication_start"
#                       key must be defined. If no such configuration key 
#                       value is defined the corresponding dialog box will
#                       not appear.
#
# "title"               is a user defined title or "standard" to display
#                       the default title.
#                       This parameter must be defined if the
#                       dialog_specific_key has been defined.
#
# "message"             is a user defined message or "standard" to display the
#                       default message.  Note that for a user defined message
#                       the '|' character can be used to create a new line in
#                       the message. See the example given below.
#
# "diag-format"         this parameter defines the button format of the dialog
#                       box and may be one of:
#                       "Quit-Cont"  for the two [ QUIT ] [ CONTINUE ] buttons
#                       "Cont"       for just the [ CONTINUE ] button
#                       This is an optional parameter, default "Quit-Cont".
#
# "diag-freq"           gives the frequency with which the dialog box should be
#                       displayed and may be one of:
#                       "never" for no dialog box to appear
#                       "once"  to appear only once
#                       "repeat" to always appear at the key moment defined by
#                       the dialog_specific_key
#                       This is an optional parameter, default "once".
#
# for example the following user defined dialog definition:
#
# dialog_communication_start: [ "Attention !" "Press Green button on XYZ prober.|Then press CONTINUE." "Cont" ]
#
# will mean the following dialog box
#
#           ============== Attention ! ==============
#           |                                       |
#           | Press Green button on XYZ prober.     |
#           | Then press CONTINUE.                  |
#           |                                       |
#           |             [ Continue ]              |
#           |                                       |
#           =========================================
#
#
# appears before any communication is sent to the prober/handler by the driver.
#




# Parameters for Interface Identification -------------------------------------


# Handlers or wafer probers may be connected through a GPIB, 
# LAN(TCP/IP) or RS232 interface to the tester. (Some equipment even supports more
# than one interface type).  This parameter specifies the interface
# type used.  "gpib" refers to a
# GPIB interface. "lan" refers to a LAN(TCP/IP) interface. "rs232"
# refers to a RS232 interface.

{ The handler interface type. Must be defined, no default }

interface_type: < F >                   "gpio"

# The name of the interface device. 
# For GPIB interface, this symbolic name is known to the standard instrument 
# control library (SICL), which is declared to the SICL through the iosetup(1) 
# program and are stored in the file /etc/opt/sicl/hwconfig.cf.
# For LAN interface, the format of the symbolic interface looks like:
# "[TCP/UDP]/server_address/server_port"
# For example:
# 1. TCP/192.168.1.1/12345
# 2. UDP/192.168.1.1/12345
# 3. TCP/server_hostname/12345
# 4. UDP/server_hostname/12345
# For RS232 interface, the format of the symbolic interface look like:
# "rs232/dev/device_name"
# For example:
# "rs232/dev/ttyS0"

{ The name of the interface device. Must be defined, no default }

symbolic_interface_name: < F >          "gpio"


# Parameters for Site Management ----------------------------------------------


# Specifies the number of sites of the handler, and the ID of each
# site. Each string element of the array is a site ID. The number of
# elements is the number of sites.
#
# The order and naming of the site IDs should match the handler
# documentation to avoid confusion. The left most entry refers to the
# first handler site, the right most entry refers to the last handler
# site.

{ The names of the handler sites, Must be defined, no default }

handler_site_ids:                       [ "1" "2" "3" ]

# This mask tells the driver which of the handler sites are active
# (=1) and which are (currently) deactivated (=0). The mask
# corresponds to handler_site_ids. Telling the driver about
# deactivated sites avoids unnecessary latency delays.

{ Mask of active handler sites, entries may be 0 or 1, default [ 1 1 1 ... ] }

handler_site_mask:                      [ 1 1 1 ]

# Site mapping (corresponds to handler site IDs):
# Each entry defines the SmarTest site, the corresponding handler site is
# feeding to. SmarTest site numbers always start with 1 and are
# incremental. I.e. if 4 sites are defined, the SmarTest site numbers
# 1 to 4 must occur in the site mapping, while the order of these
# numbers may vary.
#
# Example:
# Assuming the 'handler_site_ids' are set to                 [ "A" "B" "C" ]
# and the      'smartest_site_to_handler_site_map' is set to [  2   1   3  ]
#
# This situation would result in:
#
# handler site "A" is mapped to SmarTest site 2
# handler site "B" is mapped to SmarTest site 1
# handler site "c" is mapped to SmarTest site 3

{ Mapping of SmarTest sites to handler sites, entries are >= 1,
  default [ 1 2 3 ... ] }

smartest_site_to_handler_site_map:      [ 1 2 3 ]


# Bin management --------------------------------------------------------------


# This parameter selects one of the different ways the driver can map
# SmarTest bins to handler bins:
#
# - "default"
# - "mapped-hardbins"
# - "mapped-softbins"
#
# Whenever a device is binned to a specific SmarTest bin, the handler
# will receive the mapped handler bin code for this device. Depending
# on the mapping selected, more or less additional parameters must be
# set, as described below.
#
# "default" is the easiest way to specify the device
# binning. SmarTest's hardbin numbers are used for a mapping of
# SmarTest bins to handler bins in a straight one to one fashion: The
# SmarTest bin with hardbin number 0 is mapped the handler bin 0,
# the SmarTest bin with harbin number 1 is mapped to handler bin 1,
# and so on. There are no further parameters to be set.
#
# "mapped-hardbins" provides a method to assign (groups of) SmarTest
# bins to (groups of) handler bins. The hardbin numbers of the
# SmarTest bins are used for bin identification. To use this feature,
# the parameters handler_bin_ids and hardbin_to_handler_bin_map must
# be defined, as explained below.
#
# "mapped-softbins" provides a method to assign (groups of) SmarTest
# bins to (groups of) handler bins. The softbin number of the SmarTest
# bins are used for bin identification. To use this feature, the
# parameters handler_bin_ids and softbin_to_handler_bin_map must be
# defined, as explained below.

{ Method of SmarTest to handler bin mapping. Must be defined, 
  "default", "mapped-hardbins", or "mapped-softbins" }

bin_mapping:                            "default"

# Holds the IDs of the bins of a handler. The IDs used in the array
# must match the bin names as known to the handler's communication
# protocol. The IDs in the array are used by so-called `message based'
# handlers, which identify bins over the GPIB (IEEE-488) or RS232
# interface. When a handler is connected via a GPIB interface, the bin
# IDs are used for message and error logging of the driver, and to
# allow for the `mapped-hardbins' or `mapped-softbins' binning
# modes.
#
# The definition of handler_bin_ids is optional, if the "default" bin
# mapping is used. It is mandatory, if either the "mapped-hardbins" or
# the "mapped-softbins" method is used.

{ The names of the handler bins, no default }

handler_bin_ids:                        [ "A" "B" "C" "D" ]

# Defines the handler bins to be used for unknown test results. A test
# result is unknown, if the device test was skipped.
#
# If the parameter handler_bin_ids IS NOT defined (this is allowed
# when `default' bin mapping is used), the entries of the
# handler_retest_bins definition are directly interpreted as the
# plug-in internal bin numbers (which start with 0).
#
# If the parameter handler_bin_ids IS defined, the entries of the
# handler_retest_bins definition are interpreted as indices to the
# handler_bin_ids array. Note that the first entry in that array has
# the index number 0)
#
# Some handlers bin to a retest bin when they receive an end-of-test
# signal or a binning signal without receiving binning data (which
# specifies the bin). In this case handler_retest_bins must be
# assigned an empty list (handler_retest_bins: [ ]).

{ List of handler retest bin indices, 0 to ..., default: no retest bins }

handler_retest_bins:                    [ 3 ]

# Hardbin mapping (corresponds to handler bin IDs):
#
# The format of this definition is a list of lists of SmarTest hardbin
# numbers. Each of the inner SmarTest hardbin lists refers to one
# handler bin, which was defined in 'handler_bin_ids'. Equal SmarTest
# bins may be given in several lists. The handler driver than takes
# care about an equal handler bin usage distribution.
#
# To avoid confusions, this definition should only be given, if
# 'bin_mapping' was set to "mapped-hardbins"
#
# Detailed example:
#
# handler_retest_bins:        [ 4 5 ]
# handler_bin_ids:            [ "A" "B"   "C"     "D"   "E"  "F"  ]
# hardbin_to_handler_bin_map: [ [1] [2] [98 99] [98 99] [0]  [0] ]
#
# Handler bin "A" will receive devices binned to hardbin 1
# Handler bin "B" will receive devices binned to hardbin 2
#
# Handler bins "C" and "D" will both receive devices binned to
# hardbin 98 or 99
#
# Handler bins "E" and "F" will both receive devices binned to 
# default bin 0.

{ SmartTest hard-bin to handler bin map,
  list of lists of SmarTest hard-bin numbers, no default }

hardbin_to_handler_bin_map:             [ [ 1 ] [ 2 ] [ 3 ] [ 4 ] ]

# Softbin mapping (corresponds to handler bin IDs):
#
# The format of this definition is a list of lists of SmarTest softbin
# identifiers. Each of the inner SmarTest softbin lists refers to one
# handler bin, which was defined in 'handler_bin_ids'. Equal SmarTest
# bins may be given in several lists. The handler driver than takes
# care about an equal handler bin usage distribution.
#
# To avoid confusions, this definition should only be given, if
# 'bin_mapping' was set to "mapped-softbins"
#
# Detailed example:
#
# handler_retest_bins:        [ 4 ]
# handler_bin_ids:            [  "A"    "B"       "C"         "D"      "E"   ]
# softbin_to_handler_bin_map: [ ["1"]  ["2"]   ["3" "4"]   ["3" "4"]  ["0"] ]
#
# Handler bin "A" will receive devices binned to softbin "1"
# Handler bin "B" will receive devices binned to softbin "2"
#
# Handler bins "C" and "D" will both receive devices binned to softbin
# "3" or "4"
#
# Handler bin "E" will receive devices that were binned to default bin "0".

{ SmartTest soft-bin to handler bin map,
  list of lists of SmarTest soft-bin codes, no default }

softbin_to_handler_bin_map:             [ ["1"] ["2"] ["3"] ["4"] ]


# Parameters for Reprobe Activation -------------------------------------------

# NOTE: Reprobe is usually not supported by GPIO handlers.


# If driver function ph_reprobe() is called via TC-API PHSession::reprobe(), 
# based on the value of this parameter, the driver will either ignore that reprobe
# request ("off"), will reprobe all devices regardless of their test
# results ("all"). This parameter can be configured as "per-site", but as SmarTest8
# has no reprobe bin defined, the effect of "per-site" is equal to the effect of "all".

{ how to reprobe during automatic reprobe actions }

automatic_reprobe_mode:                 "per-site"


# Parameters for Temperature Setup --------------------------------------------



# Parameters for GPIO Waveform Setup ------------------------------------------


# These parameters define whether the communication signals (the DUT
# signal (test start), the binning information, and the end-of-test
# signal) between tester and handler are active low ("negative"), or
# active high ("positive). Usually negative polarity is used.

{ The polarity of the test-start signal, "positive" or "negative",
  default depends on driver plug-in }

test_start_polarity:                    "negative"

{ The polarity of the end-of-test signal, "positive" or "negative",
  default depends on driver plug-in }

end_of_test_polarity:                   "negative"

{ The polarity of the bin data, "positive" or "negative",
  default depends on driver plug-in }

bin_data_polarity:                      "negative"

# Tells the driver whether the test start signal sent by the handler
# is a "pulse" (two edges) or a "static" signal (one edge, for
# example, the signal is pulled to low until the binning information
# was received).

{ The waveform of the test start signal, "pulse" or "static",
  default depends on driver plug-in }

test_start_waveform:                    "pulse"

# Some handlers define a minimum time between sending the test start
# signal and being able to receive an end of test signal. This may be
# a problem, if the device test is very fast. In this case the
# following definition may be given. The value is set in milliseconds

{ The minimum device test time as expected by the handler in milliseconds, 
  0 to ..., default depends on driver plug-in }

end_of_test_delay_time:                 100

# In case the handler has a missalignment between its physical device
# plungers and sending the test start signal, the device test may fail
# if started too early. In this case, the following definition may be
# used to artificially delay the device test of SmarTest after
# receiving all test start signals from the handler. The time is given
# in milliseconds.

{ Delay to start SmarTest device test, 0 to ..., 
  default depends on driver plug-in }

device_test_delay_time:                 0

# The time in milliseconds the driver will wait for the binning
# signals to become stable, before it sends the end-of-test signal to
# the handler.

{ Time in milliseconds for binning signals to become stable before EOT,
  0 to ..., default depends on driver plug-in }

bin_data_setup_time:                    1

# The width of the end-of-test pulse in milliseconds.

{ Pulse width of EOT signal in milliseconds,
  0 to ..., default depends on driver plug-in }

end_of_test_pulse_width:                2
 
# The time in milliseconds the driver will keep the bin data signal
# stable after the end-of-test pulse.

{ Time in milliseconds for binning signals to remain stable after EOT,
  0 to ..., default depends on driver plug-in }

bin_data_hold_time:                     3
 
# If the handler's test start signals in a multi site scenario are not
# synchronized very accurately, the driver accepts a latency between
# the test start signals of two or more sites defined by this
# parameter. If a test start signal was not received within this
# latency time, the driver finally assumes, that one or more sockets
# have not been populated with devices. Depending on how well the test
# start signals are synchronized and on how often devices are really
# missing, a reasonable value must be chosen. The value is given in
# milliseconds.

{ Maximum time to wait for missing test start signals for multi site handlers,
  0 to ..., default depends on driver plug-in }

maximum_multi_site_latency:             100
 
# Some handlers which use the GPIO interface may either work in
# "serial" binning mode or in "parallel" binning mode (as far as
# supported). This parameter tells the driver which binning mode the
# handler uses. Parallel binning uses only one end-of-test pulse (or
# simultaneous end-of-test pulses for each site) and several small
# groups of bin lines per site. Serial binning uses sequential
# end-of-test pulse (one per site), and typically one (larger) group of bin
# lines. Typically, serial binning takes more time but may distinguish
# between more binning categories. However, this is handler specific.

{ How to send multi site binning information to the handler, "serial"
  or "parallel", default depends on driver plug-in }

binning_mode:                           "parallel"
 
# The minimum time in milliseconds between subsequent end-of-test
# pulses for serial binning. The time is needed for processing of the
# binning signals by the handler.

{ Minimum time interval between serial binning information in milliseconds, 
  0 to ..., default depends on driver plug-in }

serial_bin_interval:                    30
 
# Determines whether the driver will send binning data to the handler
# "explicit" (decoded, using one data line for each bin) or "encoded"
# (using multiple data lines to define a binary bin number). Encoded
# binning supports more bin categories, but is not supported by all
# handlers. Note: The plug-in internal bin numbering starts with 0.
#
# Example:
# bin number    explicit bin data       encoded bin data
# 
#     0             0001                    00
#     1             0010                    01
#     2             0100                    10
#     3             1000                    11

{ Coding of bin data, "encoded" or "explicit", 
  default depends on driver plug-in }

bin_coding:                             "explicit"
 
# The following definition defines, whether the bin information is
# pulsed to the handler or remains static. If bin information is
# pulsed, the output levels of the bin lines go back into the inactive
# state according to the bin_data_polarity definition after the bin
# data has been send. Otherwise they remain with set bin information
# until the next device is binned.

{ The waveform of the binning data, "pulse" or "static, 
  default depends on driver plug-in }

bin_waveform:                           "pulse"
 
# The following definitions assigns GPIO output data lines to bin
# lines of the handler's sites. The format is a list of pairs of GPIO
# data output lines. Each pair refers to one handler site. A pair
# defines the least significant bit and the most significant bit (in
# this order) of the bin data. It selects a group continuous lines of
# the GPIO output bus. Depending on the bin_coding, this groups is
# either used to strobe one single bin category or to send a binary
# coded bin number. The definition must be given for each handler
# site, even if the binning_mode is set to 'serial'. In this case each
# site may use the same bin signals.
#
# Valid values for the output lines are "DO0" to "DO15"
#
# Examples:
#
# The first example assigns GPIO lines 0 to 4 to site A, lines 5 to 9
# to site B, and lines 14 to 10 (in a reversed order) to site C. A
# parallel binning mode is used.
#
# handler_site_ids:                     [ "A" "B" "C" ]
# binning_mode:                         "parallel"
# per_site_bin_line_groups:             [ [ "DO0" "DO4" ] 
#                                         [ "DO5" "DO9" ] 
#                                         [ "DO14" "DO10" ] ]
#
# The next example assignes GPIO lines 1 to 15 to both sites A and B
# in a serial binning mode.
#
# handler_site_ids:                     [ "A" "B"  ]
# binning_mode:                         "serial"
# per_site_bin_line_groups:             [ [ "DO1" "DO15" ] 
#                                         [ "DO1" "DO15" ] ]

{ The groups of GPIO output lines used for each handler site to send the 
  binning information, list of pairs of GPIO output lines, 
  default depends on driver plug-in }

per_site_bin_line_groups:               [ [ "DO0" "DO3" ] [ "DO4" "DO7" ] [ "DO8" "DO11" ] ]

# Most of the handlers use one or more end of test signals to read in
# the binning information. In case of serial binning, usually
# different end of test lines are used for different sites. In case of
# parallel binning, often only one end of test line is used to clock
# in all binning information to the handler at once.
#
# On the other hand, some handlers that use an explicit binning may
# not need an additional end of test signal.
#
# In case the following definition is given, it is assumed, that the
# handler needs to receive an end of test pulse for each site. Even if
# it is working in parallel mode, an entry for each site must be given,
# most likely with equal values for each site. This provides a maximum
# range of functionality.
#
# Valid values for the output lines are "DO0" to "DO15", "CTL0", and "CTL1"
#
# If the definition is not given, it is assumed, that no explicit end
# of test pulses are necessary. In this case the bin_coding must be
# set to "explicit" and the bin_waveform must be "pulse".
#
# Examples:
#
# This defines a serial binning using output lines 1 to 15 of the GPIO
# interface to provide the bin category, using the CTL0 line for site
# A and the CTL1 line for site B.
#
# handler_site_ids:                     [ "A" "B"  ]
# binning_mode:                         "serial"
# per_site_bin_line_groups:             [ [ "DO1" "DO15" ] [ "DO1" "DO15" ] ]
# per_site_end_of_test_line:            [ "CTL0" "CTL1" ]
#
# This defines a parallel binning with two separated groups of bin
# information lines for both sites A and B. Both sites use the same
# end of test line CTL0. Only one end of test pulse is generated!
#
# handler_site_ids:                     [ "A" "B"  ]
# binning_mode:                         "parallel"
# per_site_bin_line_groups:             [ [ "DO0" "DO7" ] [ "DO8" "DO15" ] ]
# per_site_end_of_test_line:            [ "CTL0" "CTL0" ]
#

{ The GPIO output lines used for each handler site to send the end-of-test 
  signal, list GPIO output lines, default depends on driver plug-in }

per_site_end_of_test_line:              [ "DO13" "DO14" "DO15" ]

# On a multi site handler, usually each site reports its DUT population
# status through a different control line. Sometimes these lines are
# pulsed, if a device is inserted and no additional test start signal
# is provided. Sometimes, the status lines are set to population
# status and a global test start signal clocks in the information to
# the tester. In both cases, the following definition selects the GPIO
# input lines to be used for the DUT signal of each site.
#
# If the definition is given, it must define a value for each handler
# site according to handler_site_ids.
#
# Valid entries are "DI0" to "DI15", STI0, STI1, and EIR
#
# If the definition is not given at all, it is assumed that only a
# global test start signal is provided by the handler and it is
# assumed that allways all sites are populated on test start. In this
# case global_test_start_must be defined.

{ The GPIO input lines used for each handler site to receive the test-start
  signal, list GPIO input lines, default depends on driver plug-in }

per_site_test_start_line:               [ "DI0" "DI1" "DI2" ]

# In addition to the per_site_test_start_line definition, some
# handlers provide a global test start signal. It is used to clock in
# the per site DUT information or is the only start signal for single
# site handlers.
#
# If the following definition is given, it is used to trigger the test
# start sequence.
#
# Valid entries are "DI0" to "DI15", "STI0", "STI1", and "EIR"
#
# If the definition is not given, per_site_test_start_line must be
# defined and is assumed to provide per DUT start signals.

{ The GPIO input line used for a global test-start signal, 
  GPIO input lines, default depends on driver plug-in }

global_test_start_line:                 "STI0"

# Using the HP GPIO Interface box E2828A-560 test start signals are
# usually latched on rising edges. This leads to the fact, that
# combinations of per DUT start signals with a global start signal may
# fail, if the DUT start signals are active low and the latches are
# read out directly after receiving the global test start signal. See
# Diagram:
#
# DUT start signal (handler):    -----\_________/------------
#                                               :
# latched DUT start signal:      ---------------\____________
#
# global start signal (handler): --------\__/---------------
#                                           :
# latched global start signal:   -----------\_______________
#
# failure to read latched                     ^
# DUT lines here -----------------------------|
#
# To deal with this problem, the following parameter defines a minimum
# read delay time between the latched test start signal and the
# latched DUT start signals. The definition is only active, if both
# global_test_start_line and per_site_test_start_lines are given. The
# delay time is given in milliseconds.
# Note: For an "ngpio" interface type a gpio_box_dut_read_delay_time  
# should not be specified. For the "ngpio" set-up ( GPIO card E2790C  
# without the GPIO Interface box E2828A-560) latches are set on the   
# negative edge for a "negative" test_start_polarity and a positive   
# edge for a "positive" test start polarity.

{ The delay to apply to read the per site test-start lines after
  receiving a global test-start signal in millisecods, 0 to ..., 

gpio_box_dut_read_delay_time:           5

# Using the HP GPIO Interface box E2828A-560 test start signals are
# usually latched. After binning the current devices, it must be
# ensured, that the previous test start latches are cleared. The GPIO
# bos provides latch clear functionality for different GPIO output
# lines depending on the current jumpering inside the box. If not
# already pulsed during device binning, the GPIO lines in the
# following definition are pulsed to reset the GPIO box latches.
# Note: For an "ngpio" interface type gpio_box_clear_latch_lines 
# should not be specified since the GPIO E2790C card has latches 
# which are cleared internally.
#
# Valid values are "CTL0" and "CTL1"

{ The GPIO output line used to reset the GPIO box latches,
  list of GPIO output lines, default depends on driver plug-in }

gpio_box_clear_latch_lines:             [ "CTL0" "CTL1" ]


# Plugin specific parameters --------------------------------------------------


# Parameters for Driver Internals ---------------------------------------------


# This parameter is used as communication heartbeat timeout value.

{ Heartbeat timeout value for communications between the tester and equipment, 
  0 to ..., default: 5000 }

flag_check_interval:                    4000

# During GPIO communication, pulses are generated and received. For
# all these operations, the driver must run so-called delay loops
# between the individual driver actions in order to perform one action
# at a fixed time after another action (for example, the generation of
# the second edge of a pulse at a fixed time after the first edge.)
#
# Delay loops may either be performed in a busy-wait manner or by
# using a timer of the operating system.
#
# This parameter defines the threshold for the delay loop duration (in
# microseconds) to decide which algorithm the driver will use. For
# delay loops below this threshold, busy-wait will be used, for those
# above the threshold, timers.
#
# Busy-wait loops cause high system load but are very accurate. Timers
# are less accurate but produce significantly less system load.
#
# A typical system timer has a resolution of 10ms. Thus, setting
# busy_wait_delay_threshold to 1ms and trying to produce a 2 ms
# end-of-test pulse would result in a 10 ms pulse.
#
# Thus, it is advisable to use busy-wait loops for small delay times,
# while for longer delay times, timers should be used.

{ Cut of time to switch from busy wait delay to system timer delay in 
  microseconds, 0 to ..., default: 5000 }

busy_wait_delay_threshold: < F >        5000

# Determines whether the driver will use a "polling" or an "interrupt"
# based algorithm while waiting for parts.
# Either the driver repeatedly checks whether the handler has sent
# the test start signal (polling), or the driver expects an SRQ 
# from the handler to indicate parts are ready to test (interrupt).

{ How to wait for test-start signals on the GPIO port, "polling" or
  "interrupt", default: "polling" }

waiting_for_parts_method: < F >         "polling"

# If the driver uses the polling method while waiting for parts, this
# parameter defines the time in microseconds between two polling
# operations. Typical values lie between 500 and 500000
# microseconds. Choosing a value larger than busy_wait_delay_threshold
# avoids high system load when waiting for parts. A value lower than
# busy_wait_delay_threshold should be chosen if fastest reaction time
# to test start signals is desired.

{ The polling interval for test-start signals in microseconds, 
  0 to ..., default: 10000 }

polling_interval: < F >                 10000

# Only used for debugging: work with simulated SmarTest flags

{ Simulate SmarTest flags, "yes" or "no", default: "no" }

smartest_simulation: < F >              "no"

# Only used for debugging: work with simulated plugin operation

{ Simulate plugin operations, "yes" or "no", default: "no" }

plugin_simulation: < F >                "yes"


# End of File -----------------------------------------------------------------
