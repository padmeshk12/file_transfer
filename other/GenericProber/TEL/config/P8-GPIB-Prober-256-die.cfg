# -----------------------------------------------------------------------------
#      This is a prober specific configuration file for prober drivers
#         (c) Copyright Advantest 2015
# -----------------------------------------------------------------------------
# The general syntax of this file is:
#
#       file           = definitionlist
#
#       definitionlist = definition [definitionlist]
#
#       definition     = [hint] key [flags] data
#
#       key            = string ':'
#
#       data           = array | simple_data
#
#       simple_data    = number | quoted_string
#
#       quoted_string  = '"' string '"' | ''' string '''
#
#       array          = '[' datalist ']'
#
#       datalist       =  data [datalist]
#
#       hint           = '{' string '}'
#
#       flags          = '<' characterlist '>'
#
#       characterlist  = character [characterlist]
#
#       string         = alphanumeric string
#
#       number         = any floating point number
#
#       character      = 'F'
#
# Everything following a '#' character up to the end of the line, is 
# treated as a comment. A '#' within a string is handled correctly
# as part of the string.
#
# A <hint> group (several continuous lines) immediately preceding a 
# <definition> is used as a hint for this definition and will occur
# as tooltip in a user interface to give some advise for possible
# changes.
#
#           For a detailed description please refer to the document
#                     "Prober/Handler Drivers"
# -----------------------------------------------------------------------------



# Parameters for Equipment Identification -------------------------------------


# The name of the prober family, as accepted by the plug-in.

{ The name of the prober family }

prober_family: < F >                    "TEL"

# The name of the specific prober model within the prober family, as
# accepted by the plug-in

{ The name of the prober model }

model: < F >                            "P-8"


# Parameters for Log File Generation ------------------------------------------


# In addition to printing messages to the Report Window, the driver
# can also write these messages to a file.  If the following value is
# not an empty string, it is treated as a log file for driver
# messages. Environment variable substitution in the path definition
# works.

{ The location of the drivers message log file }

driver_message_log:                     "/opt/hp93000/testcell/phcontrol/log/messages"

# For debugging purposes, the driver may generate more or less detailed
# messages. The level of details is defined by this parameter.  If not
# specified differently in the attributes definition, the parameter
# settings -1 (no messages) ... 4 (highest detail) or 9 are valid.
# debug level 9 will output highest detail (4), plus the time stamp

{ The debug level of the driver }

debug_level:                            0

# In addition to printing warnings and errors to the Report Window,
# the driver can also write these to a file. Also `trace' information
# will be written to this file. If the following value is not an empty
# string, it is treated as an additional log file for errors and
# warnings. Environment variable substitution in the path definition
# works.

{ The location of the drivers error log file }

driver_error_log:                       "/opt/hp93000/testcell/phcontrol/log/errors"

# The messages and warnings/errors log files generated by the driver
# may be kept or overwritten with each start-up of the driver (each
# testprogram run), or with each change of one of the parameters
# driver_message_log or driver_error_log. This parameter sets the
# number of old log files to be kept by renaming the files following
# the scheme:
#
# file -> file_old_1 -> file_old_2 -> file_old_3 -> ... 
# -> file_old_<log_files_to_keep>

{ How many old log files with similar names to keep, default: 0 }

log_files_to_keep: < F >                0

# The driver may log the contents of the driver configuration file which
# was loaded at driver start-up to the message log output.  If set to
# "yes", this configuration will be logged at the ph_driver_start call
# from the test cell client.

{ Log configuration to the message log file, default: "no" }

log_configuration: < F >                "yes"

# If set to "yes", the driver will add internal function calls
# together with the passed parameters to the warnings/error
# output. This should be used for debugging only.

{ Trace driver internal function calls, default: "no" }

trace_driver_calls:                     "no"


# Parameters for Driver Mode --------------------------------------------------


# For demonstrations, debug scenarios, and problem analysis, the
# driver may work in "off-line" mode rather then in "on-line"
# mode. During off-line mode, no communication with the equipment
# takes place. Instead, the equipment's behavior is simulated to the
# driver (error-free operation is simulated).

{ Interface communication mode, default: "on-line" }

communication_mode: < F >               "on-line"

# Sometimes it is necessary to slow down all driver operations, for
# example when testing a new test cell client, or when analyzing a
# malfunction. This parameter sets the driver to the single step
# mode. In single step mode the operator is prompted for confirmation
# at each call from the test cell client to the prober driver.

{ Activate singel step mode, default: "off" }

single_step_mode:                       "off"


# Parameters for Operator interventions ---------------------------------------


# At driver startup, the operator may be asked to confirm the current
# configuration. If the operator confirms the configuration, handling
# operation will start. Otherwise, the testprogram will be
# aborted. The driver will only ask for configuration confirmation, if
# also the parameter log_configuration is set to "yes". This prints
# the current configuration file to the report window, and this way
# allows the operator to check the configuration before confirming it.

{ Ask for confirmation of the configuration at driver startup, default: "no" }

ask_for_configuration_confirmation: < F > "no"

# If a timeout occurs while the driver waits for the next part to be
# tested (next device from the handler, or next die on the wafer), the
# driver can ask the operator to take action ("operator-help"), or can
# continue waiting for parts ("continue"). In the latter case, the
# driver will stop waiting only if a new part is delivered by the
# handler or prober (and the delivery is recognized).

{ What should happen, if a timeout occurs while waiting for parts,
  default: "continue" }

waiting_for_parts_timeout_action:       "continue"

# The time in seconds which the driver will wait for a new part (for
# handlers: the next device; for probers: the next die) from the
# equipment. If this time is exceeded (timeout), a message will be
# generated by the driver, and the action defined by the parameter
# waiting_for_parts_timeout_action will be taken.

{ Timeout in [seconds] to probe a die, default: 30 }

waiting_for_parts_timeout:              30

# These parameters work exactly like waiting_for_parts_timeout_action,
# but for timeouts while the driver waits for the next wafer to be
# delivered by the prober.

{ What should happen, if a timeout occurs while waiting for wafers,
  default: "continue" }

waiting_for_wafer_timeout_action:       "continue"

# The time in seconds which the driver will wait for a new wafer to be
# inserted by the prober. If this time is exceeded (timeout), a message
# will be generated by the driver, and the action defined by the
# parameters waiting_for_wafer_timeout_action will be taken.

{ Timeout in [seconds] to provide a wafer, default: 120 }

waiting_for_wafer_timeout:              240

# These parameters work exactly like waiting_for_parts_timeout_action,
# but for timeouts while the driver waits for the next cassette to be
# delivered by the prober.

{ What should happen, if a timeout occurs while waiting for cassettes,
  default: "continue" }

waiting_for_cassette_timeout_action:    "continue"

# The time in seconds which the driver will wait for a new cassette from
# the equipment. If this time is exceeded (timeout), a message will be
# generated by the driver, and the action defined by the parameter
# waiting_for_wafer_timeout_action will be taken.

{ Timeout in [seconds] to proviude a cassette, default: 120 }

waiting_for_cassette_timeout:           300

# The time in seconds which the driver will wait for a new lot to
# be started by the prober. If this time is exceeded (timeout), a
# message will be generated by the driver, and the action defined by the
# parameters waiting_for_lot_timeout_action will be taken.

{ What should happen, if a timeout occurs while waiting for a lot start,
  default: "continue" }

waiting_for_lot_timeout_action:         "operator-help"

# The time in seconds which the driver will wait for the prober to
# report that a new lot is ready to be tested. Some probers send out a
# special signal in this situation. Other probers do not. In the
# case of a timeout, a message will be generated by the driver, and the
# action defined by the parameter waiting_for_lot_timeout_action will be
# taken (see above). If the action is "operator-help", the operator can
# tell the driver to proceed as if the signal had been received.  The
# exact implementation of this function is plug-in specific.

{ Timeout in [seconds] to start a new lot, default: 120 }

waiting_for_lot_timeout:                300

# If a timeout occurs while the driver waits for any signals from the
# equipment, other than waiting for parts, wafers, cassettes or lots,
# the driver can ask the operator to take action ("operator-help"), or
# can continue waiting for the current action to complete
# ("continue"). In the latter case, the driver will stop waiting only if
# the action is completed.

{ What should happen, if a general timeout occurs, default: "continue" }

general_timeout_action:                 "continue"

# The time in seconds which the driver will wait to receive any signal
# from the equipment, other than those signals for which the waiting
# time is defined by the parameters waiting_for_*_timeout (see
# above). The parameter general_timeout, for example, applies to
# communication requests when setting up parameters of the prober,
# requesting values, pausing/unpausing, and asking for IDs.  If this
# time is exceeded (timeout), a message will be generated by the driver,
# and the action defined by the parameter general_timeout_action will be
# taken (see above).

{ Timeout in [seconds] to wait for completion of a general
  communication, default: 30 }

general_timeout:                        30

# This parameter determines whether the prober will be paused by the
# driver when the ph_pause_start() is called by TC-API PHSession::pause().
# Depending on the prober type, the driver will make the prober 
# leave the pause mode again, when the ph_pause_done() is called by
# TC-API PHSession::resume().

{ Do we stop the prober when PHSession::pause() is called, default: "no" }

stop_prober_on_smartest_pause:          "no"


# User Defined Dialog Box -----------------------------------------------------

# At certain key moments during the operation of the driver a configurable
# dialog box can be set to appear. The idea being that the operator may be
# prompted to perform some action to ensure the smooth operation of the
# prober/handler and the driver. For each user defined dialog box the
# following parameters may be defined:
#
# dialog_specific_key: [ "title" "message" "diag-format" "diag-freq" ]
#
# where:
#
# dialog_specific_key   is the configuration key value as defined below.
#                       For example, to make a user defined dialog box
#                       appear before any commmunication is sent to the
#                       prober/handler the "dialog_communication_start"
#                       key must be defined. If no such configuration key 
#                       value is defined the corresponding dialog box will
#                       not appear.
#
# "title"               is a user defined title or "standard" to display
#                       the default title.
#                       This parameter must be defined if the
#                       dialog_specific_key has been defined.
#
# "message"             is a user defined message or "standard" to display the
#                       default message.  Note that for a user defined message
#                       the '|' character can be used to create a new line in
#                       the message. See the example given below.
#
# "diag-format"         this parameter defines the button format of the dialog
#                       box and may be one of:
#                       "Quit-Cont"  for the two [ QUIT ] [ CONTINUE ] buttons
#                       "Cont"       for just the [ CONTINUE ] button
#                       This is an optional parameter, default "Quit-Cont".
#
# "diag-freq"           gives the frequency with which the dialog box should be
#                       displayed and may be one of:
#                       "never" for no dialog box to appear
#                       "once"  to appear only once
#                       "repeat" to always appear at the key moment defined by
#                       the dialog_specific_key
#                       This is an optional parameter, default "once".
#
# for example the following user defined dialog definition:
#
# dialog_communication_start: [ "Attention !" "Press Green button on XYZ prober.|Then press CONTINUE." "Cont" ]
#
# will mean the following dialog box
#
#           ============== Attention ! ==============
#           |                                       |
#           | Press Green button on XYZ prober.     |
#           | Then press CONTINUE.                  |
#           |                                       |
#           |             [ Continue ]              |
#           |                                       |
#           =========================================
#
#
# appears before any communication is sent to the prober/handler by the driver.
#



# User defined dialog box to appear before communication to the handler/
# prober starts. For details on how to set the parameters see the
# "User Defined Dialog" entry above. Note for the diag-freq setting
# "repeat" is not an allowable value.

{ User defined dialog box to be appear before any communication is sent to the
  prober/handler }

dialog_communication_start: < F >       [ "standard" "standard" "quit-cont" "never" ] 

# User defined dialog box to appear before any configuration values are
# sent to the handler/prober. For details on how to set the parameters see the
# "User Defined Dialog" entry above. Note for the diag-freq setting
# "repeat" is not an allowable value.

{ User defined dialog box to be appear before any configuration values are
  sent to the prober/handler }


dialog_configuration_start: < F >       [ "standard" "standard" "quit-cont" "never" ] 

# User defined dialog box to appear before the lot level is started.
# For details on how to set the parameters see the "User Defined Dialog"
# entry above.

{ User defined dialog box to be appear before the lot level is started }


dialog_lot_start: < F >                 [ "standard" "standard" "quit-cont" "never" ] 

# User defined dialog box to appear before the wafer level is started.
# For details on how to set the parameters see the "User Defined Dialog"
# entry above.

{ User defined dialog box to be appear before the wafer level is started }


dialog_wafer_start: < F >               [ "standard" "standard" "quit-cont" "never" ]


# Parameters for Interface Identification -------------------------------------


# Handlers or wafer probers may be connected through a GPIB, or
# LAN(TCP/IP) interface to the tester. (Some equipment even supports more
# than one interface type).  This parameter specifies the interface
# type used. "gpib" refers to a
# GPIB interface. "lan" refers to a LAN(TCP/IP) interface.

{ The prober interface type }

interface_type: < F >                   "gpib"

# The name of the interface device.
# For GPIB interface, this symbolic name is known to the standard instrument
# control library (SICL), whic is declared to the SICL through the iosetup(1)
# program and are stored in the file /etc/opt/sicl/hwconfig.cf.
# For LAN interface, the format of the symbolic interface looks like:
# "[TCP/UDP]/server_address/server_port"
# For example:
# 1. TCP/192.168.1.1/12345
# 2. UDP/192.168.1.1/12345
# 3. TCP/server_hostname/12345
# 4. UDP/server_hostname/12345

{ The name of the interface device }

symbolic_interface_name: < F >          "hpib"

# The GPIB port number of the prober or handler. This parameter is not required
# for LAN interface.

{ The GPIB port number of the prober or handler, no default }

gpib_port: < F >                        22

# In case a prober or handler generates SRQs on the GPIB interface,
# that are not expected by the driver plugin, the plugin usually stops
# operation and the driver fails. This happens to ensure that the
# driver plugin is always synchronized with the equipment state. In
# case of an incomplete plugin implementation, it may happen that some
# SRQs are not handled correctly. To avoid time loss due to bug
# reports and new driver releases at production sites, this
# configuration parameters allows to ignore certain SRQs in
# general.
#
# Warning: Each given SRQ value in the list will be
# completely ignored. If SRQs are entered, that are needed by the
# driver plugin in some situations but should be ignored in other
# situations, this parameter can not be used.
#
# In case this parameter is used, a report should be send to your 
# Advantest representative to help improve future driver plugin 
# releases. 

{ A list of SQRs to be completely ignored by the driver plugin, 
  default empty list }

ignored_SRQs: < F >                     [ ]


# Parameters for Site Management ----------------------------------------------


# Specifies the number of sites of the prober, and the ID of each
# site. Each string element of the array is a site ID. The number of
# elements is the number of sites. 
#
# The order and naming of the site IDs should match the prober
# documentation to avoid confusion. The left most entry refers to the
# first prober site, the right most entry refers to the last prober
# site. 

{ The names of the prober sites }

prober_site_ids: < F >                  [ "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15" "16" "17" "18" "19" "20" "21"  "22" "23" "24" "25" "26" "27" "28" "29" "30" "31" "32" "33" "34" "35" "36" "37" "38" "39" "40" "41" "42" "43" "44" "45" "46" "47" "48" "49" "50" "51" "52" "53" "54" "55" "56" "57" "58" "59" "60" "61" "62" "63" "64" "65" "66" "67" "68" "69" "70" "71" "72" "73" "74" "75" "76" "77" "78" "79" "80" "81" "82" "83" "84" "85" "86" "87" "88" "89" "90" "91" "92" "93" "94" "95" "96" "97" "98" "99" "100" "101" "102" "103" "104" "105" "106" "107" "108" "109" "110" "111" "112" "113" "114" "115" "116" "117" "118" "119" "120" "121" "122" "123" "124" "125" "126" "127" "128" "129" "130" "131" "132" "133" "134" "135" "136" "137" "138" "139" "140" "141""142" "143" "144" "145" "146" "147" "148" "149" "150" "151" "152" "153" "154" "155" "156" "157" "158" "159" "160" "161" "162" "163" "164" "165" "166" "167" "168" "169" "170" "171" "172" "173" "174" "175" "176" "177" "178" "179" "180" "181" "182" "183" "184" "185" "186" "187" "188" "189" "190" "191" "192" "193" "194" "195" "196" "197" "198" "199" "200" "201" "202" "203" "204" "205" "206" "207" "208" "209" "210" "211" "212" "213" "214" "215" "216" "217" "218" "219" "220" "221" "222" "223" "224" "225" "226" "227" "228" "229" "230" "231" "232" "233" "234" "235" "236" "237" "238" "239" "240" "241" "242" "243" "244" "245" "246" "247" "248" "249" "250" "251" "252" "253" "254" "255" "256"]

# This mask tells the driver which of the prober sites are active
# (=1) and which are (currently) deactivated (=0). The mask
# corresponds to prober_site_ids. Telling the driver about
# deactivated sites avoids unnecessary latency delays.

{ Mask of active prober sites, entries may be 0 or 1, default [ 1 1 1 ... ] }

prober_site_mask:                       [ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ]

# Site mapping (corresponds to prober site IDs):
# Each entry defines the SmarTest site, the corresponding prober site is 
# feeding to. SmarTest site numbers always start with 1 and are
# incremental. I.e. if 4 sites are defined, the SmarTest site numbers
# 1 to 4 must occur in the site mapping, while the order of these
# numbers may vary.
#
# Example:
# Assuming the 'prober_site_ids' are set to                 [ "A" "B" "C" ]
# and the      'smartest_site_to_prober_site_map' is set to [  2   1   3  ]
#
# This situation would result in:
#
# prober site "A" is mapped to SmarTest site 2
# prober site "B" is mapped to SmarTest site 1
# prober site "c" is mapped to SmarTest site 3

{ Mapping of SmarTest sites to prober sites, entries are >= 1, 
  default [ 1 2 3 ... ] }

smartest_site_to_prober_site_map: < F > [ 1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 ]


# Bin management --------------------------------------------------------------


# This parameter selects one of the different ways the driver can map
# SmarTest bins to prober bins:
#
# - "default"
# - "mapped-hardbins"
# - "mapped-softbins"
# - "default_softbin_mapping"
#
# Whenever a device is binned to a specific SmarTest bin, the prober
# will receive the mapped prober bin code for this device. Depending
# on the mapping selected, more or less additional parameters must be
# set, as described below.
#
# "default" and "default_softbin_mapping" is the easiest way to specify the device
# binning. SmarTest's hardbin/softbin numbers are used for a mapping of
# SmarTest bins to prober bins in a straight one to one fashion: The
# SmarTest bin with hardbin/softbin number 0 is mapped to the prober bin 0;
# the SmarTest bin with harbin/softbin number 1 is mapped to the prober bin 1;
# and so on. There are no further parameters to be set.
#
# "mapped-hardbins" provides a method to assign (groups of) SmarTest
# bins to (groups of) prober bins. The hardbin numbers of the
# SmarTest bins are used for bin identification. To use this feature,
# the parameters prober_bin_ids and hardbin_to_prober_bin_map must
# be defined, as explained below.
#
# "mapped-softbins" provides a method to assign (groups of) SmarTest
# bins to (groups of) prober bins. The softbin codes of the SmarTest
# bins are used for bin identification. To use this feature, the
# parameters prober_bin_ids and softbin_to_prober_bin_map must be
# defined, as explained below.

{ Method of SmarTest to prober bin mapping }

bin_mapping: < F >                      "default"

# Holds the IDs of the bins of a prober. The IDs used in the array
# must match the bin names as known to the prober's communication
# protocol. The IDs in the array are used by so-called `message based'
# probers, which identify bins over the GPIB (IEEE-488) or RS232
# interface. When a prober is connected via a GPIB interface, the bin
# IDs are used for message and error logging of the driver, and to
# allow for the `mapped-hardbins' or `mapped-softbins' binning
# modes.
#
# The definition of prober_bin_ids is optional, if the "default" bin
# mapping is used. It is mandatory, if either the "mapped-hardbins" or
# the "mapped-softbins" method is used.

{ The names of the prober bins }

prober_bin_ids: < F >                   [ "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15" "16" "17" "18" "19" "20" "21" "22" "23" "24" "25" "26" "27" "28" "29" "30" "31" ]

# Defines the prober bins to be used for unknown test results. A test
# result is unknown, if the device test was skipped.
#
# If the parameter prober_bin_ids IS NOT defined (this is allowed
# when `default' bin mapping is used), the entries of the
# prober_retest_bins definition are directly interpreted as the
# plug-in internal bin numbers (which start with 0). 
#
# If the parameter prober_bin_ids IS defined, the entries of the
# prober_retest_bins definition are interpreted as indices to the
# prober_bin_ids array. Note that the first entry in that array has
# the index number 0)
#
# Some probers bin to a retest bin when they receive an end-of-test
# signal or a binning signal without receiving binning data (which
# specifies the bin). In this case prober_retest_bins must be
# assigned an empty list (prober_retest_bins: [ ]).

{ List of prober retest bin indices, 0 to ..., default: no retest bins }

prober_retest_bins: < F >               [ 31 ]


# Parameters for specific prober functionality --------------------------------


# This parameter determines how the prober stepping is controlled.
# The parameter can be assigned one of the following values:
# 
# - "prober"
# - "smartest"
# - "learnlist"
# 
# With "prober" the prober performs the die stepping automatically and
# sends the position of every tested die to SmarTest. With "smartest"
# the driver tells the prober where to step for every device. The
# stepping pattern is taken from the wafermap of SmarTest.  "learnlist"
# is similar to "smartest", but the complete stepping pattern stored in
# the wafermap of SmarTest is send to the prober before probing
# starts. The prober than follows that pattern and no further stepping
# data is send to the prober for individual dies.
# 
# For all three parameter settings, the wafermap must be defined.
# In the case of "prober" stepping control, the wafermap must match 
# the stepping performed by the prober. Otherwise, TCCT cannot correctly 
# generate the graphical wafer test result display.

{ Who controlls the stepping pattern, default: "smartest" }

stepping_controlled_by: < F >           "prober"

# This parameter determines whether contact test function of prober driver is
# enabled or not. Prober performs contact test to find out Z Contact Height
# automatically and electrically. Z Contact Height is the Z position of prober
# chuck where the die pins(pads) get connected with the needles.

{ Whether contact test function is enabled nor not }

enable_contact_test: <F>                "no"

# In case of multi site probing, the prober driver needs to know the
# relative die positions of all sites with respect to a reference
# site. This reference site is called primary die.  This parameter
# defines a list of X/Y pairs. Each pair represents the relative die
# position of a site with respect to the primary die (the relative
# position of the primary die to itself is 0,0). The list starts with
# site 1, then site 2, and so on. The direction of X and Y axis is as
# defined in the wafermap. The values for X and Y are die count
# positions (not distances). The following examples count X to the right
# and Y to the bottom.
#
# Examples:
#
# multi_site_die_offsets: [ [0 0] [1 1] ]
# This defines a dual site probe setup where the probes of site 2 are
# in relative position 1,1 to the probes of site 1:
#
#            +---+
#            | 1 |
#            +---+---+
#                | 2 |
#                +---+
#
# multi_site_die_offsets: [ [0 0] [1 1] [2 0] [3 1] ]
# This defines a quad site probe setup whith the following site probe layout:
#
#            +---+   +---+
#            | 1 |   | 3 |
#            +---+---+---+---+
#                | 2 |   | 4 |
#                +---+   +---+
#
# If the parameter is not given, a single site probe is assumed

{ relative die positions for multi site probes, default: [ [0 0] ] }

multi_site_die_offsets: < F >           [[0 0] [0 1] [0 2] [0 3] [0 4] [0 5] [0 6] [0 7] [0 8] [0 9] [0 10] [0 11] [0 12] [0 13] [0 14] [0 15] [0 16] [0 17] [0 18] [0 19] [0 20] [0 21] [0 22] [0 23] [0 24] [0 25] [0 26] [0 27] [0 28] [0 29] [0 30] [0 31] [0 32] [0 33] [0 34] [0 35] [0 36] [0 37] [0 38] [0 39] [0 40] [0 41] [0 42] [0 43] [0 44] [0 45] [0 46] [0 47] [0 48] [0 49] [0 50] [0 51] [0 52] [0 53] [0 54] [0 55] [0 56] [0 57] [0 58] [0 59] [0 60] [0 61] [0 62] [0 63] [0 64] [0 65] [0 66] [0 67] [0 68] [0 69] [0 70] [0 71] [0 72] [0 73] [0 74] [0 75] [0 76] [0 77] [0 78] [0 79] [0 80] [0 81] [0 82] [0 83] [0 84] [0 85] [0 86] [0 87] [0 88] [0 89] [0 90] [0 91] [0 92] [0 93] [0 94] [0 95] [0 96] [0 97] [0 98] [0 99] [0 100][0 101] [0 102] [0 103] [0 104] [0 105]  [0 106] [0 107] [0 108] [0 109] [0 110][0 111] [0 112] [0 113] [0 114] [0 115] [0 116] [0 117] [0 118] [0 119] [0 120] [0 121] [0 121] [0 123] [0 124] [0 125] [0 126] [0 127] [0 128] [0 129] [0 130] [0 131] [0 132] [0 133] [0 134] [0 135] [0 136] [0 137] [0 138] [0 139] [0 140] [0 141] [0 142] [0 143] [0 144] [0 145] [0 146] [0 147] [0 148] [0 149] [1 0] [1 1] [1 2] [1 3] [1 4] [1 5] [1 6] [1 7] [1 8] [1 9] [1 10] [1 11] [1 12] [1 13] [1 14] [1 15] [1 16] [1 17] [1 18] [1 19] [1 20] [1 21] [1 22] [1 23] [1 24] [1 25] [1 26] [1 27] [1 28] [1 29] [1 30] [1 31] [1 32] [1 33] [1 34] [1 35] [1 36] [1 37] [1 38] [1 39] [1 40] [1 41] [1 42] [1 43] [1 44] [1 45] [1 46] [1 47] [1 48] [1 49] [1 50] [1 51] [1 52] [1 53] [1 54] [1 55] [1 56] [1 57] [1 58] [1 59] [1 60] [1 61] [1 62] [1 63] [1 64] [1 65] [1 66] [1 67] [1 68] [1 69] [1 70][1 71] [1 72] [1 73] [1 74] [1 75] [1 76] [1 77] [1 78] [1 79] [1 80] [1 81] [1 82] [1 83] [1 84] [1 85] [1 86] [1 87] [1 88] [1 89] [1 90] [1 91] [1 92] [1 93] [1 94] [1 95] [1 96] [1 97] [1 98] [1 99] [1 100] [1 101] [1 102] [1 103] [1 104][1 105] ]

# Sometimes it is not useful or not desired, that tester sends the
# resulting binning data of a test to the prober. This may be the case
# in situations where tester controls the stepping pattern and/or in
# multi die scenarios with possibly overlapping step patterns. Setting
# this parameter to "yes" suppresses the sending of binning data to the
# prober.
# 
# Note: Some plug-ins may not support this feature, or only in a
# restricted way (for example, only when not probing multiple dies). In
# this case the plug-in will report an error message at start-up, and
# the parameter value must either be changed to "no", or the parameter
# must be removed from the configuration.

{ If set to "yes" tester does not send the bining data to the
prober, default "no" }

dont_bin_dies: < F >                    "no"

# If the prober supports probe needle cleaning, an automatic cleaning
# process may be issued every time after a given number of dies (or
# die groups in case of multi site probing) have been probed and
# tested.
#
# This parameter defines the cleaning rate. If set to 0 or not
# defined, no automatic probe cleaning is done based on probe
# counts. If set to a positive number, an automatic probe cleaning is
# applied after this number of probed dies.
#
# Per die probe needle cleaning may be combined with per wafer or bin
# based probe needle cleaning

{ automatic probe needle cleaning after this number of probed dies }

per_die_probe_cleaning_rate:            0

# If the prober supports probe needle cleaning, an automatic cleaning
# process may be issued every time after a given number of wafers
# have been processed.
#
# This parameter defines the cleaning rate. If set to 0 or not
# defined, no automatic probe cleaning is done based on wafer
# counts. If set to a positive number, an automatic probe cleaning is
# applied after this number of processed wafers.
#
# Per wafer probe needle cleaning may be combined with per die or bin
# based probe needle cleaning

{ automatic probe needle cleaning after this number of processed wafers }

per_wafer_probe_cleaning_rate:          0

# If the prober supports probe needle cleaning, an automatic cleaning
# process may be issued every time a tested die is binned into one of
# a set of given bin categories. By this, probe needle cleaning can be
# controlled based on the actual test result. 
#
# The parameter defines a list of SmarTest hardbins, that should imply
# an automatic probe needle cleaning. If set to empty list or not
# defined, no hardbin based probe needle cleaning applied.
#
# See also parameter probe_cleaning_softbins. Probe needle cleaning
# based on hardbins can NOT be combined with cleaning based on
# softbins, but it may be combined with per die or per wafer probe
# needle cleaning.

{ List of SmarTest hardbins that trigger a probe needle cleaning }

probe_cleaning_hardbins:                [ ]

# If the prober supports probe needle cleaning, an automatic cleaning
# process may be issued every time a tested die is binned into one of
# a set of given bin categories. By this, probe needle cleaning can be
# controlled based on the actual test result. 
#
# The parameter defines a list of SmarTest softbins, that should imply
# an automatic probe needle cleaning. If set to empty list or not
# defined, no softbin based probe needle cleaning applied.
#
# See also parameter probe_cleaning_hardbins. Probe needle cleaning
# based on softbins can NOT be combined with cleaning based on
# hardbins, but it may be combined with per die or per wafer probe
# needle cleaning.

{ List of SmarTest softbins that trigger a probe needle cleaning }

probe_cleaning_softbins:                [ ]


# Plugin specific parameters --------------------------------------------------


# For certain TEL probers the machine ID "?V" query is not a valid query. In 
# such cases the driver will fail during start-up. If this occurs the 
# following configurable value should be set to "no" to prevent the ?V 
# query being sent.

{ If set to "no" then the driver will not send out the ?V machine ID query
  , default "yes" }

tel_send_id_query:                      "yes"

# For certain TEL probers the "VF" command  (unload all wafers and force a 
# lot end) is not a valid command. In such cases the driver will fail if the 
# user decides to quit a currently running session where a wafer is still being
# probed. If this occurs the following configurable value should be set to "no" 
# to prevent the VF command being sent.

{ If set to "no" then the driver will not send out the VF wafer abort command
  , default "yes" }

tel_send_wafer_abort:                   "yes"


# Parameters for Driver Internals ---------------------------------------------

# These parameters control how the driver behaves while waiting for
# new parts to be tested, and when performing a timed sequence of
# actions.


# This parameter is used as communication heartbeat timeout value.

{ Heartbeat timeout value for communications between the tester and equipment, 
  0 to ..., default: 5000 }

flag_check_interval:                    4000

# Only used for debugging: work with simulated SmarTest flags

{ Simulate SmarTest flags, "yes" or "no", default: "no" }

smartest_simulation: < F >              "no"

# Only used for debugging: work with simulated plugin results

{ Simulate plugin results, "yes" or "no", default: "no" }

plugin_simulation: < F >                "no"

# End of File -----------------------------------------------------------------
