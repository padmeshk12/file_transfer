# -----------------------------------------------------------------------------
#      This is a prober specific configuration file for prober drivers
#         (c) Copyright Advantest 2015
# -----------------------------------------------------------------------------
# The general syntax of this file is:
#
#       file           = definitionlist
#
#       definitionlist = definition [definitionlist]
#
#       definition     = [hint] key [flags] data
#
#       key            = string ':'
#
#       data           = array | simple_data
#
#       simple_data    = number | quoted_string
#
#       quoted_string  = '"' string '"' | ''' string '''
#
#       array          = '[' datalist ']'
#
#       datalist       =  data [datalist]
#
#       hint           = '{' string '}'
#
#       flags          = '<' characterlist '>'
#
#       characterlist  = character [characterlist]
#
#       string         = alphanumeric string
#
#       number         = any floating point number
#
#       character      = 'F'
#
# Everything following a '#' character up to the end of the line, is 
# treated as a comment. A '#' within a string is handled correctly
# as part of the string.
#
# A <hint> group (several continuous lines) immediately preceding a 
# <definition> is used as a hint for this definition and will occur
# as tooltip in a user interface to give some advise for possible
# changes.
#
#           For a detailed description please refer to the document
#                     "Prober/Handler Drivers"
# -----------------------------------------------------------------------------



# Parameters for Equipment Identification -------------------------------------


# The name of the prober family, as accepted by the plug-in.

{ The name of the prober family }

prober_family: < F >                    "TEL"

# The name of the specific prober model within the prober family, as
# accepted by the plug-in

{ The name of the prober model }

model: < F >                            "P-8"


# Parameters for Log File Generation ------------------------------------------


# In addition to printing messages to the Report Window, the driver
# can also write these messages to a file.  If the following value is
# not an empty string, it is treated as a log file for driver
# messages. Environment variable substitution in the path definition
# works.

{ The location of the drivers message log file }

driver_message_log:                     "/opt/hp93000/testcell/phcontrol/log/messages"

# For debugging purposes, the driver may generate more or less detailed
# messages. The level of details is defined by this parameter.  If not
# specified differently in the attributes definition, the parameter
# settings -1 (no messages) ... 4 (highest detail) or 9 are valid.
# debug level 9 will output highest detail (4), plus the time stamp

{ The debug level of the driver }

debug_level:                            3

# In addition to printing warnings and errors to the Report Window,
# the driver can also write these to a file. Also `trace' information
# will be written to this file. If the following value is not an empty
# string, it is treated as an additional log file for errors and
# warnings. Environment variable substitution in the path definition
# works.

{ The location of the drivers error log file }

driver_error_log:                       "/opt/hp93000/testcell/phcontrol/log/errors"

# The messages and warnings/errors log files generated by the driver
# may be kept or overwritten with each start-up of the driver (each
# testprogram run), or with each change of one of the parameters
# driver_message_log or driver_error_log. This parameter sets the
# number of old log files to be kept by renaming the files following
# the scheme:
#
# file -> file_old_1 -> file_old_2 -> file_old_3 -> ... 
# -> file_old_<log_files_to_keep>

{ How many old log files with similar names to keep, default: 0 }

log_files_to_keep: < F >                0

# The driver may log the contents of the driver configuration file which
# was loaded at driver start-up to the message log output.  If set to
# "yes", this configuration will be logged at the ph_driver_start call
# from the test cell client.

{ Log configuration to the message log file, default: "no" }

log_configuration: < F >                "yes"

# If set to "yes", the driver will add internal function calls
# together with the passed parameters to the warnings/error
# output. This should be used for debugging only.

{ Trace driver internal function calls, default: "no" }

trace_driver_calls:                     "no"


# Parameters for Driver Mode --------------------------------------------------


# For demonstrations, debug scenarios, and problem analysis, the
# driver may work in "off-line" mode rather then in "on-line"
# mode. During off-line mode, no communication with the equipment
# takes place. Instead, the equipment's behavior is simulated to the
# driver (error-free operation is simulated).

{ Interface communication mode, default: "on-line" }

communication_mode: < F >               "on-line"

# Sometimes it is necessary to slow down all driver operations, for
# example when testing a new test cell client, or when analyzing a
# malfunction. This parameter sets the driver to the single step
# mode. In single step mode the operator is prompted for confirmation
# at each call from the test cell client to the prober driver.

{ Activate singel step mode, default: "off" }

single_step_mode:                       "off"


# Parameters for Operator interventions ---------------------------------------


# At driver startup, the operator may be asked to confirm the current
# configuration. If the operator confirms the configuration, handling
# operation will start. Otherwise, the testprogram will be
# aborted. The driver will only ask for configuration confirmation, if
# also the parameter log_configuration is set to "yes". This prints
# the current configuration file to the report window, and this way
# allows the operator to check the configuration before confirming it.

{ Ask for confirmation of the configuration at driver startup, default: "no" }

ask_for_configuration_confirmation: < F > "no"

# If a timeout occurs while the driver waits for the next part to be
# tested (next device from the handler, or next die on the wafer), the
# driver can ask the operator to take action ("operator-help"), or can
# continue waiting for parts ("continue"). In the latter case, the
# driver will stop waiting only if a new part is delivered by the
# handler or prober (and the delivery is recognized).

{ What should happen, if a timeout occurs while waiting for parts,
  default: "continue" }

waiting_for_parts_timeout_action:       "continue"

# The time in seconds which the driver will wait for a new part (for
# handlers: the next device; for probers: the next die) from the
# equipment. If this time is exceeded (timeout), a message will be
# generated by the driver, and the action defined by the parameter
# waiting_for_parts_timeout_action will be taken.

{ Timeout in [seconds] to probe a die, default: 30 }

waiting_for_parts_timeout:              30

# These parameters work exactly like waiting_for_parts_timeout_action,
# but for timeouts while the driver waits for the next wafer to be
# delivered by the prober.

{ What should happen, if a timeout occurs while waiting for wafers,
  default: "continue" }

waiting_for_wafer_timeout_action:       "continue"

# The time in seconds which the driver will wait for a new wafer to be
# inserted by the prober. If this time is exceeded (timeout), a message
# will be generated by the driver, and the action defined by the
# parameters waiting_for_wafer_timeout_action will be taken.

{ Timeout in [seconds] to provide a wafer, default: 120 }

waiting_for_wafer_timeout:              240

# These parameters work exactly like waiting_for_parts_timeout_action,
# but for timeouts while the driver waits for the next cassette to be
# delivered by the prober.

{ What should happen, if a timeout occurs while waiting for cassettes,
  default: "continue" }

waiting_for_cassette_timeout_action:    "continue"

# The time in seconds which the driver will wait for a new cassette from
# the equipment. If this time is exceeded (timeout), a message will be
# generated by the driver, and the action defined by the parameter
# waiting_for_wafer_timeout_action will be taken.

{ Timeout in [seconds] to proviude a cassette, default: 120 }

waiting_for_cassette_timeout:           300

# If a timeout occurs while the driver waits for any signals from the
# equipment, other than waiting for parts, wafers, cassettes or lots,
# the driver can ask the operator to take action ("operator-help"), or
# can continue waiting for the current action to complete
# ("continue"). In the latter case, the driver will stop waiting only if
# the action is completed.

{ What should happen, if a general timeout occurs, default: "continue" }

general_timeout_action:                 "continue"

# The time in seconds which the driver will wait to receive any signal
# from the equipment, other than those signals for which the waiting
# time is defined by the parameters waiting_for_*_timeout (see
# above). The parameter general_timeout, for example, applies to
# communication requests when setting up parameters of the prober,
# requesting values, pausing/unpausing, and asking for IDs.  If this
# time is exceeded (timeout), a message will be generated by the driver,
# and the action defined by the parameter general_timeout_action will be
# taken (see above).

{ Timeout in [seconds] to wait for completion of a general
  communication, default: 30 }

general_timeout:                        30

# This parameter determines whether the prober will be paused by the
# driver when the ph_pause_start() is called by TC-API PHSession::pause().
# Depending on the prober type, the driver will make the prober 
# leave the pause mode again, when the ph_pause_done() is called by
# TC-API PHSession::resume().

{ Do we stop the prober when PHSession::pause() is called, default: "no" }

stop_prober_on_smartest_pause:          "no"


# User Defined Dialog Box -----------------------------------------------------

# At certain key moments during the operation of the driver a configurable
# dialog box can be set to appear. The idea being that the operator may be
# prompted to perform some action to ensure the smooth operation of the
# prober/handler and the driver. For each user defined dialog box the
# following parameters may be defined:
#
# dialog_specific_key: [ "title" "message" "diag-format" "diag-freq" ]
#
# where:
#
# dialog_specific_key   is the configuration key value as defined below.
#                       For example, to make a user defined dialog box
#                       appear before any commmunication is sent to the
#                       prober/handler the "dialog_communication_start"
#                       key must be defined. If no such configuration key 
#                       value is defined the corresponding dialog box will
#                       not appear.
#
# "title"               is a user defined title or "standard" to display
#                       the default title.
#                       This parameter must be defined if the
#                       dialog_specific_key has been defined.
#
# "message"             is a user defined message or "standard" to display the
#                       default message.  Note that for a user defined message
#                       the '|' character can be used to create a new line in
#                       the message. See the example given below.
#
# "diag-format"         this parameter defines the button format of the dialog
#                       box and may be one of:
#                       "Quit-Cont"  for the two [ QUIT ] [ CONTINUE ] buttons
#                       "Cont"       for just the [ CONTINUE ] button
#                       This is an optional parameter, default "Quit-Cont".
#
# "diag-freq"           gives the frequency with which the dialog box should be
#                       displayed and may be one of:
#                       "never" for no dialog box to appear
#                       "once"  to appear only once
#                       "repeat" to always appear at the key moment defined by
#                       the dialog_specific_key
#                       This is an optional parameter, default "once".
#
# for example the following user defined dialog definition:
#
# dialog_communication_start: [ "Attention !" "Press Green button on XYZ prober.|Then press CONTINUE." "Cont" ]
#
# will mean the following dialog box
#
#           ============== Attention ! ==============
#           |                                       |
#           | Press Green button on XYZ prober.     |
#           | Then press CONTINUE.                  |
#           |                                       |
#           |             [ Continue ]              |
#           |                                       |
#           =========================================
#
#
# appears before any communication is sent to the prober/handler by the driver.
#



# User defined dialog box to appear before communication to the handler/
# prober starts. For details on how to set the parameters see the
# "User Defined Dialog" entry above. Note for the diag-freq setting
# "repeat" is not an allowable value.

{ User defined dialog box to be appear before any communication is sent to the
  prober/handler }

dialog_communication_start: < F >       [ "standard" "standard" "quit-cont" "never" ] 

# User defined dialog box to appear before any configuration values are
# sent to the handler/prober. For details on how to set the parameters see the
# "User Defined Dialog" entry above. Note for the diag-freq setting
# "repeat" is not an allowable value.

{ User defined dialog box to be appear before any configuration values are
  sent to the prober/handler }


dialog_configuration_start: < F >       [ "standard" "standard" "quit-cont" "never" ] 

# User defined dialog box to appear before the lot level is started.
# For details on how to set the parameters see the "User Defined Dialog"
# entry above.

{ User defined dialog box to be appear before the lot level is started }


dialog_lot_start: < F >                 [ "standard" "standard" "quit-cont" "never" ] 

# User defined dialog box to appear before the wafer level is started.
# For details on how to set the parameters see the "User Defined Dialog"
# entry above.

{ User defined dialog box to be appear before the wafer level is started }


dialog_wafer_start: < F >               [ "standard" "standard" "quit-cont" "never" ]


# Parameters for Interface Identification -------------------------------------


# Handlers or wafer probers may be connected through a GPIB, or
# LAN(TCP/IP) interface to the tester. (Some equipment even supports more
# than one interface type).  This parameter specifies the interface
# type used. "gpib" refers to a
# GPIB interface. "lan" refers to a LAN(TCP/IP) interface.

{ The prober interface type }

interface_type: < F >                   "gpib"

# The name of the interface device.
# For GPIB interface, this symbolic name is known to the standard instrument
# control library (SICL), whic is declared to the SICL through the iosetup(1)
# program and are stored in the file /etc/opt/sicl/hwconfig.cf.
# For LAN interface, the format of the symbolic interface looks like:
# "[TCP/UDP]/server_address/server_port"
# For example:
# 1. TCP/192.168.1.1/12345
# 2. UDP/192.168.1.1/12345
# 3. TCP/server_hostname/12345
# 4. UDP/server_hostname/12345

{ The name of the interface device }

symbolic_interface_name: < F >          "hpib"

# The GPIB port number of the prober or handler. This parameter is not required
# for LAN interface.

{ The GPIB port number of the prober or handler, no default }

gpib_port: < F >                        22

# In case a prober or handler generates SRQs on the GPIB interface,
# that are not expected by the driver plugin, the plugin usually stops
# operation and the driver fails. This happens to ensure that the
# driver plugin is always synchronized with the equipment state. In
# case of an incomplete plugin implementation, it may happen that some
# SRQs are not handled correctly. To avoid time loss due to bug
# reports and new driver releases at production sites, this
# configuration parameters allows to ignore certain SRQs in
# general.
#
# Warning: Each given SRQ value in the list will be
# completely ignored. If SRQs are entered, that are needed by the
# driver plugin in some situations but should be ignored in other
# situations, this parameter can not be used.
#
# In case this parameter is used, a report should be send to your 
# Advantest representative to help improve future driver plugin 
# releases. 

{ A list of SQRs to be completely ignored by the driver plugin, 
  default empty list }

ignored_SRQs: < F >                     [ ]


# Parameters for Site Management ----------------------------------------------


# Specifies the number of sites of the prober, and the ID of each
# site. Each string element of the array is a site ID. The number of
# elements is the number of sites. 
#
# The order and naming of the site IDs should match the prober
# documentation to avoid confusion. The left most entry refers to the
# first prober site, the right most entry refers to the last prober
# site. 

{ The names of the prober sites }

prober_site_ids: < F >                  [ "1" "2" "3" "4" ]

# This mask tells the driver which of the prober sites are active
# (=1) and which are (currently) deactivated (=0). The mask
# corresponds to prober_site_ids. Telling the driver about
# deactivated sites avoids unnecessary latency delays.

{ Mask of active prober sites, entries may be 0 or 1, default [ 1 1 1 ... ] }

prober_site_mask:                       [ 1 1 1 1]

# Site mapping (corresponds to prober site IDs):
# Each entry defines the SmarTest site, the corresponding prober site is 
# feeding to. SmarTest site numbers always start with 1 and are
# incremental. I.e. if 4 sites are defined, the SmarTest site numbers
# 1 to 4 must occur in the site mapping, while the order of these
# numbers may vary.
#
# Example:
# Assuming the 'prober_site_ids' are set to                 [ "A" "B" "C" ]
# and the      'smartest_site_to_prober_site_map' is set to [  2   1   3  ]
#
# This situation would result in:
#
# prober site "A" is mapped to SmarTest site 2
# prober site "B" is mapped to SmarTest site 1
# prober site "c" is mapped to SmarTest site 3

{ Mapping of SmarTest sites to prober sites, entries are >= 1, 
  default [ 1 2 3 ... ] }

smartest_site_to_prober_site_map: < F > [ 1 2 3 4]


# Bin management --------------------------------------------------------------


# This parameter selects one of the different ways the driver can map
# SmarTest bins to prober bins:
#
# - "default"
# - "mapped-hardbins"
# - "mapped-softbins"
# - "default_softbin_mapping"
#
# Whenever a device is binned to a specific SmarTest bin, the prober
# will receive the mapped prober bin code for this device. Depending
# on the mapping selected, more or less additional parameters must be
# set, as described below.
#
# "default" and "default_softbin_mapping" is the easiest way to specify the device
# binning. SmarTest's hardbin/softbin numbers are used for a mapping of
# SmarTest bins to prober bins in a straight one to one fashion: The
# SmarTest bin with hardbin/softbin number 0 is mapped to the prober bin 0;
# the SmarTest bin with harbin/softbin number 1 is mapped to the prober bin 1;
# and so on. There are no further parameters to be set.
#
# "mapped-hardbins" provides a method to assign (groups of) SmarTest
# bins to (groups of) prober bins. The hardbin numbers of the
# SmarTest bins are used for bin identification. To use this feature,
# the parameters prober_bin_ids and hardbin_to_prober_bin_map must
# be defined, as explained below.
#
# "mapped-softbins" provides a method to assign (groups of) SmarTest
# bins to (groups of) prober bins. The softbin codes of the SmarTest
# bins are used for bin identification. To use this feature, the
# parameters prober_bin_ids and softbin_to_prober_bin_map must be
# defined, as explained below.

{ Method of SmarTest to prober bin mapping }

bin_mapping:                            "default"

# Holds the IDs of the bins of a prober. The IDs used in the array
# must match the bin names as known to the prober's communication
# protocol. The IDs in the array are used by so-called `message based'
# probers, which identify bins over the GPIB (IEEE-488) or RS232
# interface. When a prober is connected via a GPIB interface, the bin
# IDs are used for message and error logging of the driver, and to
# allow for the `mapped-hardbins' or `mapped-softbins' binning
# modes.
#
# The definition of prober_bin_ids is optional, if the "default" bin
# mapping is used. It is mandatory, if either the "mapped-hardbins" or
# the "mapped-softbins" method is used.

{ The names of the prober bins }

prober_bin_ids:                         [ "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15" "16" "17" "18" "19" "20" "21" "22" "23" "24" "25" "26" "27" "28" "29" "30" "31" ]

# Defines the prober bins to be used for unknown test results. A test
# result is unknown, if the device test was skipped.
#
# If the parameter prober_bin_ids IS NOT defined (this is allowed
# when `default' bin mapping is used), the entries of the
# prober_retest_bins definition are directly interpreted as the
# plug-in internal bin numbers (which start with 0). 
#
# If the parameter prober_bin_ids IS defined, the entries of the
# prober_retest_bins definition are interpreted as indices to the
# prober_bin_ids array. Note that the first entry in that array has
# the index number 0)
#
# Some probers bin to a retest bin when they receive an end-of-test
# signal or a binning signal without receiving binning data (which
# specifies the bin). In this case prober_retest_bins must be
# assigned an empty list (prober_retest_bins: [ ]).

{ List of prober retest bin indices, 0 to ..., default: no retest bins }

prober_retest_bins:                     [ ]


# Parameters for specific prober functionality --------------------------------


# This parameter determines how the prober stepping is controlled.
# The parameter can be assigned one of the following values:
# 
# - "prober"
# - "smartest"
# - "learnlist"
# 
# With "prober" the prober performs the die stepping automatically and
# sends the position of every tested die to SmarTest. With "smartest"
# the driver tells the prober where to step for every device. The
# stepping pattern is taken from the wafermap of SmarTest.  "learnlist"
# is similar to "smartest", but the complete stepping pattern stored in
# the wafermap of SmarTest is send to the prober before probing
# starts. The prober than follows that pattern and no further stepping
# data is send to the prober for individual dies.
# 
# For all three parameter settings, the wafermap must be defined.
# In the case of "prober" stepping control, the wafermap must match 
# the stepping performed by the prober. Otherwise, TCCT cannot correctly 
# generate the graphical wafer test result display.

{ Who controlls the stepping pattern, default: "smartest" }

stepping_controlled_by: < F >           "prober"

# This parameter determines whether contact test function of prober driver is
# enabled or not. Prober performs contact test to find out Z Contact Height
# automatically and electrically. Z Contact Height is the Z position of prober
# chuck where the die pins(pads) get connected with the needles.

{ Whether contact test function is enabled nor not }

enable_contact_test: <F>                "no"

# In case of multi site probing, the prober driver needs to know the
# relative die positions of all sites with respect to a reference
# site. This reference site is called primary die.  This parameter
# defines a list of X/Y pairs. Each pair represents the relative die
# position of a site with respect to the primary die (the relative
# position of the primary die to itself is 0,0). The list starts with
# site 1, then site 2, and so on. The direction of X and Y axis is as
# defined in the wafermap. The values for X and Y are die count
# positions (not distances). The following examples count X to the right
# and Y to the bottom.
#
# Examples:
#
# multi_site_die_offsets: [ [0 0] [1 1] ]
# This defines a dual site probe setup where the probes of site 2 are
# in relative position 1,1 to the probes of site 1:
#
#            +---+
#            | 1 |
#            +---+---+
#                | 2 |
#                +---+
#
# multi_site_die_offsets: [ [0 0] [1 1] [2 0] [3 1] ]
# This defines a quad site probe setup whith the following site probe layout:
#
#            +---+   +---+
#            | 1 |   | 3 |
#            +---+---+---+---+
#                | 2 |   | 4 |
#                +---+   +---+
#
# If the parameter is not given, a single site probe is assumed

{ relative die positions for multi site probes, default: [ [0 0] ] }

multi_site_die_offsets: < F >           [ [0 0] [1 0] [2 0] [3 0]]

# Some probers support immediate or delayed die inking. If this
# parameter is set to "yes", the driver will send an ink command the
# prober, based on the binning definition, whenever a die has failed.
# 
# Note: Some plug-ins may not support this feature, or only in a
# restricted way (for example, only when not probing multiple dies). In
# this case the plug-in will report an error message at start-up, and
# the parameter value must either be changed to "no", or the parameter
# must be removed from the configuration.

{ If set to "yes" the prober is asked to ink dies that have failed the
  test, default "no" }

ink_bad_dies:                           "yes"

# If the prober supports probe needle cleaning, an automatic cleaning
# process may be issued every time after a given number of dies (or
# die groups in case of multi site probing) have been probed and
# tested.
#
# This parameter defines the cleaning rate. If set to 0 or not
# defined, no automatic probe cleaning is done based on probe
# counts. If set to a positive number, an automatic probe cleaning is
# applied after this number of probed dies.
#
# Per die probe needle cleaning may be combined with per wafer or bin
# based probe needle cleaning

{ automatic probe needle cleaning after this number of probed dies }

per_die_probe_cleaning_rate:            0

# If the prober supports probe needle cleaning, an automatic cleaning
# process may be issued every time after a given number of wafers
# have been processed.
#
# This parameter defines the cleaning rate. If set to 0 or not
# defined, no automatic probe cleaning is done based on wafer
# counts. If set to a positive number, an automatic probe cleaning is
# applied after this number of processed wafers.
#
# Per wafer probe needle cleaning may be combined with per die or bin
# based probe needle cleaning

{ automatic probe needle cleaning after this number of processed wafers }

per_wafer_probe_cleaning_rate:          0

# If the prober supports probe needle cleaning, an automatic cleaning
# process may be issued every time a tested die is binned into one of
# a set of given bin categories. By this, probe needle cleaning can be
# controlled based on the actual test result. 
#
# The parameter defines a list of SmarTest hardbins, that should imply
# an automatic probe needle cleaning. If set to empty list or not
# defined, no hardbin based probe needle cleaning applied.
#
# See also parameter probe_cleaning_softbins. Probe needle cleaning
# based on hardbins can NOT be combined with cleaning based on
# softbins, but it may be combined with per die or per wafer probe
# needle cleaning.

{ List of SmarTest hardbins that trigger a probe needle cleaning }

probe_cleaning_hardbins:                [ ]

# If the prober supports probe needle cleaning, an automatic cleaning
# process may be issued every time a tested die is binned into one of
# a set of given bin categories. By this, probe needle cleaning can be
# controlled based on the actual test result. 
#
# The parameter defines a list of SmarTest softbins, that should imply
# an automatic probe needle cleaning. If set to empty list or not
# defined, no softbin based probe needle cleaning applied.
#
# See also parameter probe_cleaning_hardbins. Probe needle cleaning
# based on softbins can NOT be combined with cleaning based on
# hardbins, but it may be combined with per die or per wafer probe
# needle cleaning.

{ List of SmarTest softbins that trigger a probe needle cleaning }

probe_cleaning_softbins:                [ ]


# Plugin specific parameters --------------------------------------------------


# For certain TEL probers the machine ID "?V" query is not a valid query. In 
# such cases the driver will fail during start-up. If this occurs the 
# following configurable value should be set to "no" to prevent the ?V 
# query being sent.

{ If set to "no" then the driver will not send out the ?V machine ID query
  , default "yes" }

tel_send_id_query:                      "yes"

# For certain TEL probers the "VF" command  (unload all wafers and force a 
# lot end) is not a valid command. In such cases the driver will fail if the 
# user decides to quit a currently running session where a wafer is still being
# probed. If this occurs the following configurable value should be set to "no" 
# to prevent the VF command being sent.

{ If set to "no" then the driver will not send out the VF wafer abort command
  , default "yes" }

tel_send_wafer_abort:                   "yes"


# Parameters for Driver Internals ---------------------------------------------

# These parameters control how the driver behaves while waiting for
# new parts to be tested, and when performing a timed sequence of
# actions.


# This parameter is used as communication heartbeat timeout value.

{ Heartbeat timeout value for communications between the tester and equipment, 
  0 to ..., default: 5000 }

flag_check_interval:                    4000

# Only used for debugging: work with simulated SmarTest flags

{ Simulate SmarTest flags, "yes" or "no", default: "no" }

smartest_simulation: < F >              "no"

# Only used for debugging: work with simulated plugin results

{ Simulate plugin results, "yes" or "no", default: "no" }

plugin_simulation: < F >                "no"

# End of File -----------------------------------------------------------------
