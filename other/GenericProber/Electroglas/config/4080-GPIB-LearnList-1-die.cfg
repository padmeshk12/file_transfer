# -----------------------------------------------------------------------------
#      This is a prober specific configuration file for prober drivers
#         (c) Copyright Advantest 2015
# -----------------------------------------------------------------------------
# The general syntax of this file is:
#
#       file           = definitionlist
#
#       definitionlist = definition [definitionlist]
#
#       definition     = [hint] key [flags] data
#
#       key            = string ':'
#
#       data           = array | simple_data
#
#       simple_data    = number | quoted_string
#
#       quoted_string  = '"' string '"' | ''' string '''
#
#       array          = '[' datalist ']'
#
#       datalist       =  data [datalist]
#
#       hint           = '{' string '}'
#
#       flags          = '<' characterlist '>'
#
#       characterlist  = character [characterlist]
#
#       string         = alphanumeric string
#
#       number         = any floating point number
#
#       character      = 'F'
#
# Everything following a '#' character up to the end of the line, is 
# treated as a comment. A '#' within a string is handled correctly
# as part of the string.
#
# A <hint> group (several continuous lines) immediately preceding a 
# <definition> is used as a hint for this definition and will occur
# as tooltip in a user interface to give some advise for possible
# changes.
#
#           For a detailed description please refer to the document
#                     "Prober/Handler Drivers"
# -----------------------------------------------------------------------------



# Parameters for Equipment Identification -------------------------------------


# The name of the prober family, as accepted by the plug-in.

{ The name of the prober family }

prober_family: < F >                   "Electroglas"

# The name of the specific prober model within the prober family, as
# accepted by the plug-in

{ The name of the prober model }

model: < F >                            "4080"


# Parameters for Log File Generation ------------------------------------------


# In addition to printing messages to the Report Window, the driver
# can also write these messages to a file.  If the following value is
# not an empty string, it is treated as a log file for driver
# messages. Environment variable substitution in the path definition
# works.

{ The location of the drivers message log file }

driver_message_log:                     "/opt/hp93000/testcell/phcontrol/log/messages"

# For debugging purposes, the driver may generate more or less detailed
# messages. The level of details is defined by this parameter.  If not
# specified differently in the attributes definition, the parameter
# settings -1 (no messages) ... 4 (highest detail) or 9 are valid.
# debug level 9 will output highest detail (4), plus the time stamp

{ The debug level of the driver }

debug_level:                            0

# In addition to printing warnings and errors to the Report Window,
# the driver can also write these to a file. Also `trace' information
# will be written to this file. If the following value is not an empty
# string, it is treated as an additional log file for errors and
# warnings. Environment variable substitution in the path definition
# works.

{ The location of the drivers error log file }

driver_error_log:                       "/opt/hp93000/testcell/phcontrol/log/errors"

# The messages and warnings/errors log files generated by the driver
# may be kept or overwritten with each start-up of the driver (each
# testprogram run), or with each change of one of the parameters
# driver_message_log or driver_error_log. This parameter sets the
# number of old log files to be kept by renaming the files following
# the scheme:
#
# file -> file_old_1 -> file_old_2 -> file_old_3 -> ... 
# -> file_old_<log_files_to_keep>

{ How many old log files with similar names to keep, default: 0 }

log_files_to_keep:                      0

# The driver may log the contents of the driver configuration file which
# was loaded at driver start-up to the message log output.  If set to
# "yes", this configuration will be logged at the ph_driver_start call
# from the test cell client.

{ Log configuration to the message log file, default: "no" }

log_configuration: < F >                "yes"

# If set to "yes", the driver will add internal function calls
# together with the passed parameters to the warnings/error
# output. This should be used for debugging only.

{ Trace driver internal function calls, default: "no" }

trace_driver_calls:                     "no"


# Parameters for Driver Mode --------------------------------------------------


# For demonstrations, debug scenarios, and problem analysis, the
# driver may work in "off-line" mode rather then in "on-line"
# mode. During off-line mode, no communication with the equipment
# takes place. Instead, the equipment's behavior is simulated to the
# driver (error-free operation is simulated).

{ Interface communication mode, default: "on-line" }

communication_mode: < F >               "on-line"

# Sometimes it is necessary to slow down all driver operations, for
# example when testing a new test cell client, or when analyzing a
# malfunction. This parameter sets the driver to the single step
# mode. In single step mode the operator is prompted for confirmation
# at each call from the test cell client to the prober driver.

{ Activate singel step mode, default: "off" }

single_step_mode:                       "off"


# Parameters for Operator interventions ---------------------------------------


# At driver startup, the operator may be asked to confirm the current
# configuration. If the operator confirms the configuration, handling
# operation will start. Otherwise, the testprogram will be
# aborted. The driver will only ask for configuration confirmation, if
# also the parameter log_configuration is set to "yes". This prints
# the current configuration file to the report window, and this way
# allows the operator to check the configuration before confirming it.

{ Ask for confirmation of the configuration at driver startup, default: "no" }

ask_for_configuration_confirmation: < F > "no"

# If a timeout occurs while the driver waits for the next part to be
# tested (next device from the handler, or next die on the wafer), the
# driver can ask the operator to take action ("operator-help"), or can
# continue waiting for parts ("continue"). In the latter case, the
# driver will stop waiting only if a new part is delivered by the
# handler or prober (and the delivery is recognized).

{ What should happen, if a timeout occurs while waiting for parts,
  default: "continue" }

waiting_for_parts_timeout_action:       "continue"

# The time in seconds which the driver will wait for a new part (for
# handlers: the next device; for probers: the next die) from the
# equipment. If this time is exceeded (timeout), a message will be
# generated by the driver, and the action defined by the parameter
# waiting_for_parts_timeout_action will be taken.

{ Timeout in [seconds] to probe a die, default: 30 }

waiting_for_parts_timeout:              30

# These parameters work exactly like waiting_for_parts_timeout_action,
# but for timeouts while the driver waits for the next wafer to be
# delivered by the prober.

{ What should happen, if a timeout occurs while waiting for wafers,
  default: "continue" }

waiting_for_wafer_timeout_action:       "continue"

# The time in seconds which the driver will wait for a new wafer to be
# inserted by the prober. If this time is exceeded (timeout), a message
# will be generated by the driver, and the action defined by the
# parameters waiting_for_wafer_timeout_action will be taken.

{ Timeout in [seconds] to provide a wafer, default: 120 }

waiting_for_wafer_timeout:              240

# These parameters work exactly like waiting_for_parts_timeout_action,
# but for timeouts while the driver waits for the next cassette to be
# delivered by the prober.

{ What should happen, if a timeout occurs while waiting for cassettes,
  default: "continue" }

waiting_for_cassette_timeout_action:    "continue"

# The time in seconds which the driver will wait for a new cassette from
# the equipment. If this time is exceeded (timeout), a message will be
# generated by the driver, and the action defined by the parameter
# waiting_for_wafer_timeout_action will be taken.

{ Timeout in [seconds] to proviude a cassette, default: 120 }

waiting_for_cassette_timeout:           240

# The time in seconds which the driver will wait to receive any signal
# from the equipment, other than those signals for which the waiting
# time is defined by the parameters waiting_for_*_timeout (see
# above). The parameter general_timeout, for example, applies to
# communication requests when setting up parameters of the prober,
# requesting values, pausing/unpausing, and asking for IDs.  If this
# time is exceeded (timeout), a message will be generated by the driver,
# and the action defined by the parameter general_timeout_action will be
# taken (see above).

{ Timeout in [seconds] to wait for completion of a general
  communication, default: 30 }

general_timeout:			10

# This parameter determines whether the prober will be paused by the
# driver when the ph_pause_start() is called by TC-API PHSession::pause().
# Depending on the prober type, the driver will make the prober 
# leave the pause mode again, when the ph_pause_done() is called by
# TC-API PHSession::resume().

{ Do we stop the prober when PHSession::pause() is called, default: "no" }

stop_prober_on_smartest_pause:		"yes"


# User Defined Dialog Box -----------------------------------------------------

# At certain key moments during the operation of the driver a configurable
# dialog box can be set to appear. The idea being that the operator may be
# prompted to perform some action to ensure the smooth operation of the
# prober/handler and the driver. For each user defined dialog box the
# following parameters may be defined:
#
# dialog_specific_key: [ "title" "message" "diag-format" "diag-freq" ]
#
# where:
#
# dialog_specific_key   is the configuration key value as defined below.
#                       For example, to make a user defined dialog box
#                       appear before any commmunication is sent to the
#                       prober/handler the "dialog_communication_start"
#                       key must be defined. If no such configuration key 
#                       value is defined the corresponding dialog box will
#                       not appear.
#
# "title"               is a user defined title or "standard" to display
#                       the default title.
#                       This parameter must be defined if the
#                       dialog_specific_key has been defined.
#
# "message"             is a user defined message or "standard" to display the
#                       default message.  Note that for a user defined message
#                       the '|' character can be used to create a new line in
#                       the message. See the example given below.
#
# "diag-format"         this parameter defines the button format of the dialog
#                       box and may be one of:
#                       "Quit-Cont"  for the two [ QUIT ] [ CONTINUE ] buttons
#                       "Cont"       for just the [ CONTINUE ] button
#                       This is an optional parameter, default "Quit-Cont".
#
# "diag-freq"           gives the frequency with which the dialog box should be
#                       displayed and may be one of:
#                       "never" for no dialog box to appear
#                       "once"  to appear only once
#                       "repeat" to always appear at the key moment defined by
#                       the dialog_specific_key
#                       This is an optional parameter, default "once".
#
# for example the following user defined dialog definition:
#
# dialog_communication_start: [ "Attention !" "Press Green button on XYZ prober.|Then press CONTINUE." "Cont" ]
#
# will mean the following dialog box
#
#           ============== Attention ! ==============
#           |                                       |
#           | Press Green button on XYZ prober.     |
#           | Then press CONTINUE.                  |
#           |                                       |
#           |             [ Continue ]              |
#           |                                       |
#           =========================================
#
#
# appears before any communication is sent to the prober/handler by the driver.
#



# User defined dialog box to appear before communication to the handler/
# prober starts. For details on how to set the parameters see the
# "User Defined Dialog" entry above. Note for the diag-freq setting
# "repeat" is not an allowable value.

{ User defined dialog box to be appear before any communication is sent to the
  prober/handler }

dialog_communication_start: < F >      [ "standard" "standard" "quit-cont" "never" ] 

# User defined dialog box to appear before any configuration values are
# sent to the handler/prober. For details on how to set the parameters see the
# "User Defined Dialog" entry above. Note for the diag-freq setting
# "repeat" is not an allowable value.

{ User defined dialog box to be appear before any configuration values are
  sent to the prober/handler }


dialog_configuration_start: < F >      [ "standard" "standard" "quit-cont" "never" ] 

# User defined dialog box to appear before the lot level is started.
# For details on how to set the parameters see the "User Defined Dialog"
# entry above.

{ User defined dialog box to be appear before the lot level is started }


dialog_lot_start: < F >                [ "standard" "standard" "quit-cont" "never" ] 

# User defined dialog box to appear before the wafer level is started.
# For details on how to set the parameters see the "User Defined Dialog"
# entry above.

{ User defined dialog box to be appear before the wafer level is started }


dialog_wafer_start: < F >              [ "standard" "standard" "quit-cont" "never" ]


# Parameters for Interface Identification -------------------------------------


# Handlers or wafer probers may be connected through a GPIB, or
# LAN(TCP/IP) interface to the tester. (Some equipment even supports more
# than one interface type).  This parameter specifies the interface
# type used. "gpib" refers to a
# GPIB interface. "lan" refers to a LAN(TCP/IP) interface.

{ The prober interface type }

interface_type: < F >                   "gpib"

# The name of the interface device.
# For GPIB interface, this symbolic name is known to the standard instrument
# control library (SICL), whic is declared to the SICL through the iosetup(1)
# program and are stored in the file /etc/opt/sicl/hwconfig.cf.
# For LAN interface, the format of the symbolic interface looks like:
# "[TCP/UDP]/server_address/server_port"
# For example:
# 1. TCP/192.168.1.1/12345
# 2. UDP/192.168.1.1/12345
# 3. TCP/server_hostname/12345
# 4. UDP/server_hostname/12345

{ The name of the interface device }

symbolic_interface_name: < F >          "hpib"

# The GPIB port number of the prober or handler. This parameter is not required
# for LAN interface.

{ The GPIB port number of the prober or handler, no default }

gpib_port: < F >			22

# At the end of messages being send out by the GPIB interface to a
# prober or handler, the GPIB interface asserts the EOI controll line
# to indicate the end of the message. This line remains asserted until
# the next communication occurs on the GPIB bus.
#
# It has been reported that some probers or handlers do not work
# properly with the EOI line remaining asserted (seen at Electroglas
# 4080 prober in conjunction with a Electroglas station
# controller). In that case it is necessary to actively release the
# EOI line after the end of a message by enforcing a void
# communication on the GPIB bus. This may be achieved by performing
# a single serial poll (serial-poll) which results in the release of
# the EOI line. The default is not to perform any end of message 
# action (none) and leave the EOI line asserted.

{ Choose to perform void GPIB bus interactions to release the EOI
    line, default "none" }

gpib_end_of_message_action: < F >       "none"


# Parameters for Site Management ----------------------------------------------


# Specifies the number of sites of the prober, and the ID of each
# site. Each string element of the array is a site ID. The number of
# elements is the number of sites. 
#
# The order and naming of the site IDs should match the prober
# documentation to avoid confusion. The left most entry refers to the
# first prober site, the right most entry refers to the last prober
# site. 

{ The names of the prober sites }

prober_site_ids:                       [ "1" ]

# This mask tells the driver which of the prober sites are active
# (=1) and which are (currently) deactivated (=0). The mask
# corresponds to prober_site_ids. Telling the driver about
# deactivated sites avoids unnecessary latency delays.

{ Mask of active prober sites, entries may be 0 or 1, default [ 1 1 1 ... ] }

prober_site_mask:                      [ 1 ]

# Site mapping (corresponds to prober site IDs):
# Each entry defines the SmarTest site, the corresponding prober site is 
# feeding to. SmarTest site numbers always start with 1 and are
# incremental. I.e. if 4 sites are defined, the SmarTest site numbers
# 1 to 4 must occur in the site mapping, while the order of these
# numbers may vary.
#
# Example:
# Assuming the 'prober_site_ids' are set to                 [ "A" "B" "C" ]
# and the      'smartest_site_to_prober_site_map' is set to [  2   1   3  ]
#
# This situation would result in:
#
# prober site "A" is mapped to SmarTest site 2
# prober site "B" is mapped to SmarTest site 1
# prober site "c" is mapped to SmarTest site 3

{ Mapping of SmarTest sites to prober sites, entries are >= 1, 
  default [ 1 2 3 ... ] }

smartest_site_to_prober_site_map:      [ 1 ]


# Bin management --------------------------------------------------------------


# This parameter selects one of the different ways the driver can map
# SmarTest bins to prober bins:
#
# - "default"
# - "mapped-hardbins"
# - "mapped-softbins"
# - "default_softbin_mapping"
#
# Whenever a device is binned to a specific SmarTest bin, the prober
# will receive the mapped prober bin code for this device. Depending
# on the mapping selected, more or less additional parameters must be
# set, as described below.
#
# "default" and "default_softbin_mapping" is the easiest way to specify the device
# binning. SmarTest's hardbin/softbin numbers are used for a mapping of
# SmarTest bins to prober bins in a straight one to one fashion: The
# SmarTest bin with hardbin/softbin number 0 is mapped to the prober bin 0;
# the SmarTest bin with harbin/softbin number 1 is mapped to the prober bin 1;
# and so on. There are no further parameters to be set.
#
# "mapped-hardbins" provides a method to assign (groups of) SmarTest
# bins to (groups of) prober bins. The hardbin numbers of the
# SmarTest bins are used for bin identification. To use this feature,
# the parameters prober_bin_ids and hardbin_to_prober_bin_map must
# be defined, as explained below.
#
# "mapped-softbins" provides a method to assign (groups of) SmarTest
# bins to (groups of) prober bins. The softbin codes of the SmarTest
# bins are used for bin identification. To use this feature, the
# parameters prober_bin_ids and softbin_to_prober_bin_map must be
# defined, as explained below.

{ Method of SmarTest to prober bin mapping }

bin_mapping:                            "default"

# Holds the IDs of the bins of a prober. The IDs used in the array
# must match the bin names as known to the prober's communication
# protocol. The IDs in the array are used by so-called `message based'
# probers, which identify bins over the GPIB (IEEE-488) or RS232
# interface. When a prober is connected via a GPIB interface, the bin
# IDs are used for message and error logging of the driver, and to
# allow for the `mapped-hardbins' or `mapped-softbins' binning
# modes.
#
# The definition of prober_bin_ids is optional, if the "default" bin
# mapping is used. It is mandatory, if either the "mapped-hardbins" or
# the "mapped-softbins" method is used.

{ The names of the prober bins }

prober_bin_ids:                        [ "0"   "1"   "2"   "3"   "4"   "5"   "6"   "7"   "8"   "9"  "10"  "11"  "12"  "13"  "14"  "15"  "16"  "17"  "18"  "19"  "20"  "21"  "22"  "23"  "24"  "25"  "26"  "27"  "28"  "29"  "30"  "31"  "32"  "33"  "34"  "35"  "36"  "37"  "38"  "39"  "40"  "41"  "42"  "43"  "44"  "45"  "46"  "47"  "48"  "49"  "50"  "51"  "52"  "53"  "54"  "55"  "56"  "57"  "58"  "59"  "60"  "61"  "62"  "63"  "64"  "65"  "66"  "67"  "68"  "69"  "70"  "71"  "72"  "73"  "74"  "75"  "76"  "77"  "78"  "79"  "80"  "81"  "82"  "83"  "84"  "85"  "86"  "87"  "88"  "89"  "90"  "91"  "92"  "93"  "94"  "95"  "96"  "97"  "98"  "99" "100" "101" "102" "103" "104" "105" "106" "107" "108" "109" "110" "111" "112" "113" "114" "115" "116" "117" "118" "119" "120" "121" "122" "123" "124" "125" "126" "127" "128" "129" "130" "131" "132" "133" "134" "135" "136" "137" "138" "139" "140" "141" "142" "143" "144" "145" "146" "147" "148" "149" "150" "151" "152" "153" "154" "155" "156" "157" "158" "159" "160" "161" "162" "163" "164" "165" "166" "167" "168" "169" "170" "171" "172" "173" "174" "175" "176" "177" "178" "179" "180" "181" "182" "183" "184" "185" "186" "187" "188" "189" "190" "191" "192" "193" "194" "195" "196" "197" "198" "199" "200" "201" "202" "203" "204" "205" "206" "207" "208" "209" "210" "211" "212" "213" "214" "215" "216" "217" "218" "219" "220" "221" "222" "223" "224" "225" "226" "227" "228" "229" "230" "231" "232" "233" "234" "235" "236" "237" "238" "239" "240" "241" "242" "243" "244" "245" "246" "247" "248" "249" "250" "251" "252" "253" "254" "255" ]

# Defines the prober bins to be used for unknown test results. A test
# result is unknown, if the device test was skipped.
#
# If the parameter prober_bin_ids IS NOT defined (this is allowed
# when `default' bin mapping is used), the entries of the
# prober_retest_bins definition are directly interpreted as the
# plug-in internal bin numbers (which start with 0). 
#
# If the parameter prober_bin_ids IS defined, the entries of the
# prober_retest_bins definition are interpreted as indices to the
# prober_bin_ids array. Note that the first entry in that array has
# the index number 0)
#
# Some probers bin to a retest bin when they receive an end-of-test
# signal or a binning signal without receiving binning data (which
# specifies the bin). In this case prober_retest_bins must be
# assigned an empty list (prober_retest_bins: [ ]).

{ List of prober retest bin indices, 0 to ..., default: no retest bins }

prober_retest_bins:                    [ 0 ]

# Hardbin mapping (corresponds to prober bin IDs):
#
# The format of this definition is a list of lists of SmarTest hardbin
# numbers. Each of the inner SmarTest hardbin lists refers to one
# prober bin, which was defined in 'prober_bin_ids'. Equal SmarTest
# bins may be given in several lists. The prober driver than takes
# care about an equal prober bin usage distribution.
#
# To avoid confusions, this definition should only be given, if
# 'bin_mapping' was set to "mapped-hardbins"
#
# Detailed example: 
# 
# prober_retest_bins:        [ 4 5 ]
# prober_bin_ids:            [ "A" "B"   "C"     "D"   "E"  "F"  ]
# hardbin_to_prober_bin_map: [ [1] [2] [98 99] [98 99] [0]  [0] ]
#
# Prober bin "A" will receive devices binned to hardbin 1
# Prober bin "B" will receive devices binned to hardbin 2
#
# Prober bins "C" and "D" will both receive devices binned to 
# hardbin 98 or 99
#
# Prober bins "E" and "F" will both receive devices binned to 0. 
#
# In normal way, the devices binned to number which is not specified
# in the map will bin to retest bin(if retest bin is defined) or report
# error. But if the parameter "partial_binning_mode" is defined, then
# the number will be mapped in a straight one to one way. e.g. bin number
# 100 will mapped to prober bin 100.

{ SmartTest hard-bin to prober bin map, 
  list of lists of SmarTest hard-bin numbers, no default }

hardbin_to_prober_bin_map:             [ [ 1 ] [ 2 ] [ 3 ] [ 4 ] ]

# Softbin mapping (corresponds to prober bin IDs):
#
# The format of this definition is a list of lists of SmarTest softbin
# identifiers. Each of the inner SmarTest softbin lists refers to one
# prober bin, which was defined in 'prober_bin_ids'. Equal SmarTest
# bins may be given in several lists. The prober driver than takes
# care about an equal prober bin usage distribution.
#
# To avoid confusions, this definition should only be given, if
# 'bin_mapping' was set to "mapped-softbins"
#
# Detailed example: 
# 
# prober_retest_bins:        [ 4 ]
# prober_bin_ids:            [  "A"    "B"       "C"         "D"      "E"   ]
# softbin_to_prober_bin_map: [ ["1"]  ["2"]   ["3" "4"]   ["3" "4"]  ["0"] ]
#
# Prober bin "A" will receive devices binned to softbin "1"
# Prober bin "B" will receive devices binned to softbin "2"
#
# Prober bins "C" and "D" will both receive devices binned to softbin
# "3" or "4"
#
# Prober bin "E" will receive devices binned to "0".
#
# In normal way, the devices binned to number which is not specified
# in the map will bin to retest bin(if retest bin is defined) or report
# error. But if the parameter "partial_binning_mode" is defined, then
# the number will be mapped in a straight one to one way. e.g. bin number
# 100 will mapped to prober bin 100.

{ SmartTest soft-bin to prober bin map, 
  list of lists of SmarTest soft-bin codes, no default }

softbin_to_prober_bin_map:             [ ["g1"] ["g2"] ["b1"] ["b2"] ]


# Parameters for specific prober functionality --------------------------------


# This parameter determines how the prober stepping is controlled.
# The parameter can be assigned one of the following values:
# 
# - "prober"
# - "smartest"
# - "learnlist"
# 
# With "prober" the prober performs the die stepping automatically and
# sends the position of every tested die to SmarTest. With "smartest"
# the driver tells the prober where to step for every device. The
# stepping pattern is taken from the wafermap of SmarTest.  "learnlist"
# is similar to "smartest", but the complete stepping pattern stored in
# the wafermap of SmarTest is send to the prober before probing
# starts. The prober than follows that pattern and no further stepping
# data is send to the prober for individual dies.
# 
# For all three parameter settings, the wafermap must be defined.
# In the case of "prober" stepping control, the wafermap must match 
# the stepping performed by the prober. Otherwise, TCCT cannot correctly 
# generate the graphical wafer test result display.

{ Who controlls the stepping pattern, default: "smartest" }

stepping_controlled_by:			"learnlist"

# In case of multi site probing, the prober driver needs to know the
# relative die positions of all sites with respect to a reference
# site. This reference site is called primary die.  This parameter
# defines a list of X/Y pairs. Each pair represents the relative die
# position of a site with respect to the primary die (the relative
# position of the primary die to itself is 0,0). The list starts with
# site 1, then site 2, and so on. The direction of X and Y axis is as
# defined in the wafermap. The values for X and Y are die count
# positions (not distances). The following examples count X to the right
# and Y to the bottom.
#
# Examples:
#
# multi_site_die_offsets: [ [0 0] [1 1] ]
# This defines a dual site probe setup where the probes of site 2 are
# in relative position 1,1 to the probes of site 1:
#
#            +---+
#            | 1 |
#            +---+---+
#                | 2 |
#                +---+
#
# multi_site_die_offsets: [ [0 0] [1 1] [2 0] [3 1] ]
# This defines a quad site probe setup whith the following site probe layout:
#
#            +---+   +---+
#            | 1 |   | 3 |
#            +---+---+---+---+
#                | 2 |   | 4 |
#                +---+   +---+
#
# If the parameter is not given, a single site probe is assumed

{ relative die positions for multi site probes, default: [ [0 0] ] }

multi_site_die_offsets:			[ [0 0] ]

# This parameter determines whether the driver will perform the actions
# required for sub-die probing, or skip these actions.

{ flag to indicate subdie probing }

perform_subdie_probing:	< F >		"no"

# If the prober supports probe needle cleaning, an automatic cleaning
# process may be issued every time after a given number of dies (or
# die groups in case of multi site probing) have been probed and
# tested.
#
# This parameter defines the cleaning rate. If set to 0 or not
# defined, no automatic probe cleaning is done based on probe
# counts. If set to a positive number, an automatic probe cleaning is
# applied after this number of probed dies.
#
# Per die probe needle cleaning may be combined with per wafer or bin
# based probe needle cleaning

{ automatic probe needle cleaning after this number of probed dies }

per_die_probe_cleaning_rate:            0

# If the prober supports probe needle cleaning, an automatic cleaning
# process may be issued every time after a given number of wafers
# have been processed.
#
# This parameter defines the cleaning rate. If set to 0 or not
# defined, no automatic probe cleaning is done based on wafer
# counts. If set to a positive number, an automatic probe cleaning is
# applied after this number of processed wafers.
#
# Per wafer probe needle cleaning may be combined with per die or bin
# based probe needle cleaning

{ automatic probe needle cleaning after this number of processed wafers }

per_wafer_probe_cleaning_rate:          0

# If the prober supports probe needle cleaning, an automatic cleaning
# process may be issued every time a tested die is binned into one of
# a set of given bin categories. By this, probe needle cleaning can be
# controlled based on the actual test result. 
#
# The parameter defines a list of SmarTest hardbins, that should imply
# an automatic probe needle cleaning. If set to empty list or not
# defined, no hardbin based probe needle cleaning applied.
#
# See also parameter probe_cleaning_softbins. Probe needle cleaning
# based on hardbins can NOT be combined with cleaning based on
# softbins, but it may be combined with per die or per wafer probe
# needle cleaning.

{ List of SmarTest hardbins that trigger a probe needle cleaning }

probe_cleaning_hardbins:                [ ]

# If the prober supports probe needle cleaning, an automatic cleaning
# process may be issued every time a tested die is binned into one of
# a set of given bin categories. By this, probe needle cleaning can be
# controlled based on the actual test result. 
#
# The parameter defines a list of SmarTest softbins, that should imply
# an automatic probe needle cleaning. If set to empty list or not
# defined, no softbin based probe needle cleaning applied.
#
# See also parameter probe_cleaning_hardbins. Probe needle cleaning
# based on softbins can NOT be combined with cleaning based on
# hardbins, but it may be combined with per die or per wafer probe
# needle cleaning.

{ List of SmarTest softbins that trigger a probe needle cleaning }

probe_cleaning_softbins:                [ ]


# Plugin specific parameters --------------------------------------------------


# In case the parameter stepping_controlled_by is set to "learnlist",
# Electroglas probers based on the EG Commander Series firmware need a
# recipe file to store a temporary learnlist.

{ The name of a recipe file to store a learnlist on an Electroglas prober }

electroglas_recipe_file:                 "rpf"

# During the Electroglas initialization routine an "SM15" (enable
# response messages) command is sent to the prober to correctly setup
# the prober's response to various kinds of I/O commands and messages.
# However if the prober driver and the Electroglas prober are working
# together with a Electroglas station controller (typically used for
# EG 4080 models) then the necessary setup is to rely on the EG
# station controller to send out its own SM15 command to the
# prober. The driver is then not allowed to send a SM15 message,
# otherwise the station controller may be confused.
#

# If the SM15 setup command is disabled, the prober must be set up
# individually to the correct values (SM15M1111101100010), otherwise
# correct interaction with the driver is not ensured. Please refer to
# the prober manual for this operation.

{ If set to "no" then the driver will not send out the SM15 setup message 
  response command, default "yes" }

electroglas_send_setup_cmd: < F >       "yes"

# It is possible for Electroglas series of probers to operate in a more 
# efficient mode of communication. The Electroglas prober can be setup so the 
# die coordinates are sent with the test start signals. The driver must also 
# be setup with the following configuration value set to "no" so it knowns to 
# interpret these die coordinates from the test start signal and not to send a 
# separate query for the die position.

{ If set to "no" the die coordinate should be read from the test start 
  signal and a separate query for the die position should not be is is sent, 
  default "yes" }

electroglas_query_die_position:         "yes"


# Parameters for Driver Internals ---------------------------------------------

# These parameters control how the driver behaves while waiting for
# new parts to be tested, and when performing a timed sequence of
# actions.


# This parameter is used as communication heartbeat timeout value.

{ Heartbeat timeout value for communications between the tester and equipment, 
  0 to ..., default: 5000 }

flag_check_interval:                    4000

# Only used for debugging: work with simulated SmarTest flags

{ Simulate SmarTest flags, "yes" or "no", default: "no" }

smartest_simulation: < F >              "no"

# Only used for debugging: work with simulated plugin results

{ Simulate plugin results, "yes" or "no", default: "no" }

plugin_simulation: < F >                "no"

# End of File -----------------------------------------------------------------
